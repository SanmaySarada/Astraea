---
phase: 04.1-fda-compliance-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["04.1-03", "04.1-04"]
files_modified:
  - src/astraea/execution/executor.py
  - src/astraea/cli/app.py
  - tests/unit/execution/test_executor_xpt.py
  - tests/integration/execution/__init__.py
  - tests/integration/execution/test_dm_execution.py
autonomous: true

must_haves:
  truths:
    - "DatasetExecutor applies ASCII validation and character length optimization before returning"
    - "DatasetExecutor enforces SDTM-IG sort order from domain key_variables"
    - "CLI has an execute-domain command that takes a mapping spec JSON and raw data folder and produces XPT"
    - "DM domain can be executed end-to-end: spec + raw data -> SDTM DataFrame -> XPT file"
    - "Cross-domain USUBJID validation is callable after all domains are executed"
  artifacts:
    - path: "src/astraea/execution/executor.py"
      provides: "XPT-ready pipeline with ASCII/length/sort enforcement"
      exports: ["DatasetExecutor"]
    - path: "src/astraea/cli/app.py"
      provides: "execute-domain CLI command"
      contains: "execute_domain"
    - path: "tests/integration/execution/test_dm_execution.py"
      provides: "End-to-end DM execution test"
  key_links:
    - from: "src/astraea/execution/executor.py"
      to: "src/astraea/transforms/ascii_validation.py"
      via: "fix_common_non_ascii + validate_ascii calls"
      pattern: "fix_common_non_ascii|validate_ascii"
    - from: "src/astraea/execution/executor.py"
      to: "src/astraea/transforms/char_length.py"
      via: "optimize_char_lengths call"
      pattern: "optimize_char_lengths"
    - from: "src/astraea/execution/executor.py"
      to: "src/astraea/io/xpt_writer.py"
      via: "write_xpt call with optimized widths"
      pattern: "write_xpt"
    - from: "src/astraea/cli/app.py"
      to: "src/astraea/execution/executor.py"
      via: "DatasetExecutor.execute() call"
      pattern: "DatasetExecutor"
---

<objective>
Wire XPT compliance steps into the DatasetExecutor, add the execute-domain CLI command, and verify end-to-end DM execution.

Purpose: Completes the Phase 4.1 execution bridge by adding the final quality steps (ASCII cleanup, length optimization, sort enforcement) and making execution accessible via CLI. The integration test proves the full pipeline works on real DM data.

Output: Enhanced DatasetExecutor, execute-domain CLI command, integration test.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04.1-fda-compliance-infrastructure/04.1-RESEARCH.md

# Prior plan SUMMARYs needed (executor depends on these)
@.planning/phases/04.1-fda-compliance-infrastructure/04.1-03-SUMMARY.md
@.planning/phases/04.1-fda-compliance-infrastructure/04.1-04-SUMMARY.md

@src/astraea/execution/executor.py
@src/astraea/cli/app.py
@src/astraea/io/xpt_writer.py
@src/astraea/transforms/ascii_validation.py
@src/astraea/transforms/char_length.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire XPT compliance into DatasetExecutor + sort enforcement</name>
  <files>
    src/astraea/execution/executor.py
    tests/unit/execution/test_executor_xpt.py
  </files>
  <action>
    Enhance the DatasetExecutor.execute() method to add post-processing steps after the core pattern execution.

    Add these steps at the END of the execute() method (after --SEQ generation, after variable ordering, after dropping unmapped columns):

    1. **Sort rows by key_variables**: Get domain sort keys from SDTMReference (key_variables) or from spec metadata. Sort the result DataFrame by these keys with na_position="last". If SDTMReference not available, use a sensible default (STUDYID, USUBJID + domain-specific SEQ).

    2. **Fix non-ASCII characters**: Call fix_common_non_ascii(result_df) to auto-replace common non-ASCII characters. Log any replacements.

    3. **Validate remaining ASCII**: Call validate_ascii(result_df). If any non-ASCII issues remain after auto-fix, log them as warnings (do not raise -- let the XPT writer's validation catch them).

    4. **Optimize character lengths**: Call optimize_char_lengths(result_df) and store as self._last_char_widths (accessible for XPT writing).

    Add a new method: `execute_to_xpt(self, spec, raw_dfs, output_path: Path, cross_domain=None) -> Path`:
    - Call self.execute() to get the SDTM DataFrame
    - Get char_widths from self._last_char_widths
    - Build column_labels from spec.variable_mappings (sdtm_variable -> sdtm_label)
    - Call write_xpt(df, output_path, table_name=spec.domain, table_label=spec.domain_label, column_labels=column_labels, column_widths=char_widths)
    - Return the output path

    Also add a static utility: `validate_cross_domain_usubjid(dm_df: pd.DataFrame, domain_dfs: dict[str, pd.DataFrame]) -> list[str]`:
    - Get all USUBJIDs from DM
    - For each domain DataFrame, check that all its USUBJIDs exist in DM
    - Return list of error messages for any missing USUBJIDs
    - This wraps the existing validate_usubjid_consistency from transforms/usubjid.py

    Tests (test_executor_xpt.py):
    - test_ascii_fix_applied: input DataFrame with curly quotes -> output has straight quotes
    - test_char_lengths_computed: verify self._last_char_widths is populated after execute()
    - test_sort_order_applied: verify output rows are sorted by key_variables
    - test_cross_domain_validation_pass: DM with subjects A,B; AE with subjects A,B -> no errors
    - test_cross_domain_validation_fail: DM with subjects A,B; AE with subjects A,B,C -> error for C
  </action>
  <verify>
    pytest tests/unit/execution/ -x -q
  </verify>
  <done>
    DatasetExecutor applies ASCII cleanup, character length optimization, and sort order enforcement; execute_to_xpt produces XPT files with optimized column widths; cross-domain USUBJID validation utility works.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI execute-domain command + DM integration test</name>
  <files>
    src/astraea/cli/app.py
    tests/integration/execution/__init__.py
    tests/integration/execution/test_dm_execution.py
  </files>
  <action>
    Add `execute-domain` CLI command to `src/astraea/cli/app.py`:

    ```python
    @app.command()
    def execute_domain(
        spec_path: Path = typer.Argument(..., help="Path to mapping spec JSON file"),
        data_dir: Path = typer.Argument(..., help="Path to raw data directory"),
        output_dir: Path = typer.Option("output/", help="Output directory for XPT files"),
        dm_path: Path = typer.Option(None, help="Path to DM dataset (for RFSTDTC cross-domain context)"),
    ):
    ```

    Implementation (use lazy imports like other commands):
    - Load DomainMappingSpec from JSON file (spec_path)
    - Load raw DataFrames from data_dir using SASReader (read all .sas7bdat files matching spec.source_datasets)
    - If dm_path provided, load DM DataFrame and build rfstdtc_lookup (USUBJID -> RFSTDTC)
    - Create CrossDomainContext with rfstdtc_lookup
    - Create DatasetExecutor with SDTMReference and CTReference
    - Call execute_to_xpt()
    - Display Rich summary: domain, rows, columns, output path
    - Print validation summary (any ASCII issues, any missing variables)

    Create integration test `tests/integration/execution/test_dm_execution.py`:
    - This test creates a synthetic DM scenario (no real Fakedata dependency for unit-like speed)
    - Create a minimal DomainMappingSpec for DM with ~8 variables:
      STUDYID (ASSIGN), DOMAIN (ASSIGN), USUBJID (DERIVATION), SUBJID (DIRECT), SITEID (DIRECT), SEX (LOOKUP_RECODE), AGE (DERIVATION), ARMCD (DIRECT)
    - Create a raw DataFrame with 5 subjects
    - Execute through DatasetExecutor
    - Verify output DataFrame:
      - Has exactly the mapped columns
      - STUDYID is constant
      - DOMAIN is "DM"
      - Columns are in SDTM-IG order
      - No unmapped raw columns leak through
      - Character lengths are optimized (not 200)
    - Do NOT write actual XPT (avoid file system dependency in CI)
    - Create empty tests/integration/execution/__init__.py

    IMPORTANT: Use lazy imports inside the CLI command function (consistent with parse-ecrf, classify, review-domain patterns). Import DatasetExecutor, CrossDomainContext, SDTMReference, CTReference, SASReader inside the function body.
  </action>
  <verify>
    pytest tests/integration/execution/test_dm_execution.py -x -q && python -c "from astraea.cli.app import app; print('CLI app loads')"
  </verify>
  <done>
    execute-domain CLI command loads spec JSON, reads raw data, executes through DatasetExecutor, writes XPT; DM integration test proves full pipeline: spec + raw data -> SDTM DataFrame with correct columns, order, and optimized lengths.
  </done>
</task>

</tasks>

<verification>
pytest tests/unit/execution/ tests/integration/execution/ -x -q
pytest tests/ -x -q --timeout=120  # Full suite
ruff check src/astraea/execution/ src/astraea/cli/app.py
python -c "from astraea.execution import DatasetExecutor; print('Execution pipeline ready')"
</verification>

<success_criteria>
- DatasetExecutor.execute() applies ASCII fix, length optimization, and sort order as final steps
- DatasetExecutor.execute_to_xpt() produces XPT files with optimized column widths
- Cross-domain USUBJID validation utility reports subjects missing from DM
- execute-domain CLI command works: spec JSON + raw data folder -> XPT output
- DM integration test proves full execution pipeline end-to-end
- All existing 764+ tests still pass + new tests for XPT compliance and integration
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-fda-compliance-infrastructure/04.1-05-SUMMARY.md`
</output>
