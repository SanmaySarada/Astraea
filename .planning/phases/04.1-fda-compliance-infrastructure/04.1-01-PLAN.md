---
phase: 04.1-fda-compliance-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/transforms/study_day.py
  - src/astraea/transforms/sequence.py
  - src/astraea/transforms/epoch.py
  - src/astraea/transforms/visit.py
  - src/astraea/transforms/__init__.py
  - tests/unit/transforms/test_study_day.py
  - tests/unit/transforms/test_sequence.py
  - tests/unit/transforms/test_epoch.py
  - tests/unit/transforms/test_visit.py
autonomous: true

must_haves:
  truths:
    - "--DY calculation returns Day 1 for RFSTDTC, Day -1 for day before, no Day 0"
    - "--SEQ generates monotonic integers 1,2,3... within each USUBJID"
    - "EPOCH assignment maps observation dates to SE domain epoch ranges"
    - "VISITNUM/VISIT assignment maps raw visit identifiers to standardized numeric/character values"
    - "All utilities return None/NaN for partial dates or missing inputs"
  artifacts:
    - path: "src/astraea/transforms/study_day.py"
      provides: "--DY calculation with day-1 convention"
      exports: ["calculate_study_day", "calculate_study_day_column"]
    - path: "src/astraea/transforms/sequence.py"
      provides: "--SEQ generation within USUBJID groups"
      exports: ["generate_seq"]
    - path: "src/astraea/transforms/epoch.py"
      provides: "EPOCH derivation from SE domain"
      exports: ["assign_epoch"]
    - path: "src/astraea/transforms/visit.py"
      provides: "VISITNUM/VISIT assignment"
      exports: ["assign_visit"]
  key_links:
    - from: "src/astraea/transforms/__init__.py"
      to: "all new transform modules"
      via: "re-exports"
      pattern: "from astraea\\.transforms\\.(study_day|sequence|epoch|visit) import"
---

<objective>
Create the four core SDTM derivation utilities needed by every domain: --DY (study day), --SEQ (sequence number), EPOCH, and VISITNUM/VISIT.

Purpose: Phase 5+ domain expansion requires these utilities for every domain. Without them, generated datasets will fail P21 validation (missing required variables, missing timing context).

Output: Four new modules in src/astraea/transforms/ with comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04.1-fda-compliance-infrastructure/04.1-RESEARCH.md

@src/astraea/transforms/__init__.py
@src/astraea/transforms/dates.py
@src/astraea/transforms/usubjid.py
@src/astraea/models/mapping.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: --DY and --SEQ utilities</name>
  <files>
    src/astraea/transforms/study_day.py
    src/astraea/transforms/sequence.py
    tests/unit/transforms/test_study_day.py
    tests/unit/transforms/test_sequence.py
  </files>
  <action>
    Create `src/astraea/transforms/study_day.py` with two functions:

    1. `calculate_study_day(event_dtc: str, rfstdtc: str) -> int | None`:
       - Extract date portion (first 10 chars) from both ISO 8601 strings
       - Return None if either date is missing, empty, or has less than 10 chars (partial date)
       - Use the SDTM "no Day 0" convention:
         - If event_date >= ref_date: return (event_date - ref_date).days + 1
         - If event_date < ref_date: return (event_date - ref_date).days
       - Wrap date.fromisoformat() in try/except ValueError, return None on invalid dates
       - Use `from datetime import date` (NOT datetime)

    2. `calculate_study_day_column(df: pd.DataFrame, date_col: str, rfstdtc_lookup: dict[str, str], usubjid_col: str = "USUBJID") -> pd.Series`:
       - Vectorized version: for each row, look up RFSTDTC from rfstdtc_lookup[row[usubjid_col]]
       - Call calculate_study_day for each row
       - Return pd.Series with Int64 dtype (nullable integer)

    Create `src/astraea/transforms/sequence.py` with:

    1. `generate_seq(df: pd.DataFrame, domain: str, sort_keys: list[str], usubjid_col: str = "USUBJID") -> pd.Series`:
       - Build full sort key list: [usubjid_col] + [k for k in sort_keys if k != usubjid_col]
       - Filter sort_keys to only columns that exist in df (skip missing columns gracefully)
       - Sort df by full_sort with na_position="last"
       - Return groupby(usubjid_col).cumcount() + 1 as Int64
       - The returned series must have the ORIGINAL index (not the sorted index) -- use .reindex()

    Tests for study_day.py (test_study_day.py):
    - test_day_1_is_rfstdtc: calculate_study_day("2022-03-30", "2022-03-30") == 1
    - test_day_after_ref: calculate_study_day("2022-04-01", "2022-03-30") == 3
    - test_day_before_ref_no_day_zero: calculate_study_day("2022-03-29", "2022-03-30") == -1
    - test_two_days_before: calculate_study_day("2022-03-28", "2022-03-30") == -2
    - test_partial_event_date: calculate_study_day("2022-03", "2022-03-30") is None
    - test_partial_ref_date: calculate_study_day("2022-03-30", "2022") is None
    - test_empty_dates: calculate_study_day("", "2022-03-30") is None
    - test_none_dates: calculate_study_day(None, "2022-03-30") is None  -- type: ignore
    - test_datetime_event: calculate_study_day("2022-03-31T14:30:00", "2022-03-30") == 2 (extracts date portion)
    - test_column_version: 3 subjects with known dates, verify series output

    Tests for sequence.py (test_sequence.py):
    - test_single_subject: 3 rows for one subject -> SEQ 1,2,3
    - test_multiple_subjects: 2 subjects with different row counts -> each starts at 1
    - test_preserves_original_index: verify output index matches input df index
    - test_missing_sort_keys_skipped: sort_keys includes a column not in df, no error
    - test_empty_dataframe: empty df -> empty series
  </action>
  <verify>
    pytest tests/unit/transforms/test_study_day.py tests/unit/transforms/test_sequence.py -x -q
  </verify>
  <done>
    calculate_study_day correctly implements no-Day-0 convention; generate_seq produces monotonic integers within USUBJID groups; all edge cases (partial dates, empty input, multiple subjects) tested.
  </done>
</task>

<task type="auto">
  <name>Task 2: EPOCH and VISITNUM utilities + re-exports</name>
  <files>
    src/astraea/transforms/epoch.py
    src/astraea/transforms/visit.py
    src/astraea/transforms/__init__.py
    tests/unit/transforms/test_epoch.py
    tests/unit/transforms/test_visit.py
  </files>
  <action>
    Create `src/astraea/transforms/epoch.py` with:

    1. `assign_epoch(df: pd.DataFrame, se_df: pd.DataFrame, date_col: str, usubjid_col: str = "USUBJID") -> pd.Series`:
       - For each row in df, get the observation date from date_col (first 10 chars)
       - Skip if date is missing, NaN, or partial (< 10 chars)
       - Filter se_df to the same USUBJID
       - For each SE element, check if SESTDTC <= obs_date <= SEENDTC
       - If SEENDTC is missing/NaN, treat as open-ended (only check >= SESTDTC)
       - Return the matching element's EPOCH value
       - Return pd.Series with object dtype, NaN for unmatched records
       - Use string comparison for ISO 8601 dates (lexicographic order works for YYYY-MM-DD)
       - Do NOT use iterrows on the main df -- use .apply() for better performance

    Create `src/astraea/transforms/visit.py` with:

    1. `assign_visit(df: pd.DataFrame, visit_mapping: dict[str, tuple[float, str]], raw_visit_col: str = "InstanceName") -> tuple[pd.Series, pd.Series]`:
       - visit_mapping: dict mapping raw visit identifier -> (VISITNUM, VISIT)
       - For each row, look up raw_visit_col value in visit_mapping
       - Return tuple of (visitnum_series, visit_series)
       - VISITNUM is Float64 (allows decimal for unplanned visits), VISIT is object
       - Unmatched raw visit values get NaN for both VISITNUM and VISIT
       - Log warning for unmatched visit values (using loguru)

    Tests for epoch.py (test_epoch.py):
    - Build a fixture SE DataFrame with 3 elements: SCREENING (2022-01-01 to 2022-01-14), TREATMENT (2022-01-15 to 2022-06-30), FOLLOW-UP (2022-07-01 to 2022-09-30) for subject "SUBJ-001"
    - test_screening_epoch: obs date 2022-01-10 -> "SCREENING"
    - test_treatment_epoch: obs date 2022-03-15 -> "TREATMENT"
    - test_followup_epoch: obs date 2022-08-01 -> "FOLLOW-UP"
    - test_no_match_outside_range: obs date 2022-12-01 -> NaN
    - test_partial_date_returns_nan: obs date "2022-03" -> NaN
    - test_missing_date_returns_nan: obs date NaN -> NaN
    - test_open_ended_se_element: SE with missing SEENDTC, obs date after SESTDTC -> matches
    - test_multiple_subjects: two subjects with different SE data

    Tests for visit.py (test_visit.py):
    - test_mapped_visits: 3 rows with known visit names -> correct VISITNUM and VISIT
    - test_unmatched_visit: raw visit not in mapping -> NaN for both
    - test_empty_mapping: empty dict -> all NaN
    - test_decimal_visitnum: unplanned visits with VISITNUM like 2.1

    Update `src/astraea/transforms/__init__.py`:
    - Add imports from study_day, sequence, epoch, visit
    - Add all new functions to __all__
  </action>
  <verify>
    pytest tests/unit/transforms/test_epoch.py tests/unit/transforms/test_visit.py -x -q && python -c "from astraea.transforms import calculate_study_day, generate_seq, assign_epoch, assign_visit; print('All imports OK')"
  </verify>
  <done>
    EPOCH correctly assigns epoch labels from SE domain date ranges; VISITNUM/VISIT assignment works with configurable visit mapping; all new transforms re-exported from transforms/__init__.py; all tests pass.
  </done>
</task>

</tasks>

<verification>
pytest tests/unit/transforms/ -x -q
python -c "from astraea.transforms import calculate_study_day, calculate_study_day_column, generate_seq, assign_epoch, assign_visit; print('All derivation utilities importable')"
ruff check src/astraea/transforms/ tests/unit/transforms/
</verification>

<success_criteria>
- calculate_study_day implements SDTM no-Day-0 convention correctly (Day 1 = RFSTDTC)
- generate_seq produces gap-free monotonic integers within USUBJID groups
- assign_epoch maps dates to SE-domain-defined epoch ranges
- assign_visit maps raw visit identifiers to standardized VISITNUM/VISIT
- All four utilities handle edge cases: partial dates, missing values, empty DataFrames
- All existing 764+ tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-fda-compliance-infrastructure/04.1-01-SUMMARY.md`
</output>
