---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/astraea/transforms/__init__.py
  - src/astraea/transforms/dates.py
  - src/astraea/transforms/usubjid.py
  - tests/test_transforms/test_dates.py
  - tests/test_transforms/test_usubjid.py
autonomous: true

must_haves:
  truths:
    - "System converts SAS DATETIME numeric values to correct ISO 8601 strings"
    - "System converts SAS DATE numeric values to correct ISO 8601 strings"
    - "System parses string dates in multiple formats (DD Mon YYYY, DD/MM/YYYY, YYYY-MM-DD) to ISO 8601"
    - "System produces truncated ISO 8601 for partial dates (2023-03 not 2023-03-01) per SDTM-IG rules"
    - "System generates USUBJID from STUDYID + SITEID + SUBJID"
    - "System validates USUBJID consistency across domains"
  artifacts:
    - path: "src/astraea/transforms/dates.py"
      provides: "ISO 8601 date conversion utilities"
      exports: ["sas_date_to_iso", "sas_datetime_to_iso", "parse_string_date_to_iso", "format_partial_iso8601", "detect_date_format"]
    - path: "src/astraea/transforms/usubjid.py"
      provides: "USUBJID generation and validation"
      exports: ["generate_usubjid", "validate_usubjid_consistency"]
  key_links:
    - from: "src/astraea/transforms/dates.py"
      to: "Fakedata/*.sas7bdat"
      via: "converts SAS numeric dates found in raw data"
      pattern: "sas_datetime_to_iso|sas_date_to_iso"
---

<objective>
Build deterministic date conversion and USUBJID utilities -- the core data transformations used across all SDTM domains.

Purpose: Satisfies DATA-05 (ISO 8601 date conversion including partial dates) and DATA-06 (USUBJID generation and validation). These are pure functions with zero LLM dependency -- fully testable and deterministic.
Output: Date conversion and USUBJID utilities with comprehensive tests verified against real sample data values.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ISO 8601 date conversion with partial date handling</name>
  <files>
    src/astraea/transforms/dates.py
    src/astraea/transforms/__init__.py
    tests/test_transforms/test_dates.py
  </files>
  <action>
    Implement all date conversion functions. These must be deterministic -- no LLM, no guessing.

    **dates.py functions:**

    SAS_EPOCH = date(1960, 1, 1) -- SAS reference date

    **sas_date_to_iso(sas_numeric: float | None) -> str:**
    - Convert SAS date value (DAYS since 1960-01-01) to ISO 8601 "YYYY-MM-DD"
    - Return "" for None/NaN
    - Example: 22739.0 -> "2022-03-30"

    **sas_datetime_to_iso(sas_numeric: float | None) -> str:**
    - Convert SAS datetime value (SECONDS since 1960-01-01 00:00:00) to ISO 8601 "YYYY-MM-DDTHH:MM:SS"
    - Return "" for None/NaN
    - Example: 1964217600.0 -> "2022-03-15T00:00:00" (verify exact value against Fakedata)
    - CRITICAL: Do not confuse with sas_date_to_iso. The sample data uses DATETIME format (seconds), not DATE format (days). Applying the wrong conversion gives dates in year 5000+.

    **parse_string_date_to_iso(date_str: str | None) -> str:**
    - Parse various string formats to ISO 8601
    - Supported formats (detect via regex):
      - "DD Mon YYYY" (e.g., "30 Mar 2022") -> "2022-03-30" -- this is the format in Fakedata _RAW columns
      - "YYYY-MM-DD" -> pass through
      - "DD/MM/YYYY" -> "YYYY-MM-DD"
      - "MM/DD/YYYY" -> "YYYY-MM-DD" (distinguish from DD/MM/YYYY: if first field > 12, it must be DD/MM)
      - "Mon YYYY" (partial) -> "YYYY-MM"
      - "YYYY" (partial) -> "YYYY"
    - Return "" for None, empty string, or unparseable input
    - Use a format detection approach: try specific patterns in order of specificity

    **format_partial_iso8601(year, month, day, hour, minute, second) -> str:**
    - All params are int | None
    - Build ISO 8601 string truncating from the right at first None
    - "2023" (year only), "2023-03" (year-month), "2023-03-15" (full date), "2023-03-15T10:30:00" (full datetime)
    - Return "" if year is None
    - Per SDTM-IG: gaps are NOT allowed ("2023---15" is invalid)

    **detect_date_format(samples: list[str]) -> str | None:**
    - Examine sample string values and determine the format
    - Returns format name: "DD Mon YYYY", "YYYY-MM-DD", "DD/MM/YYYY", "MM/DD/YYYY", or None
    - Used by profiler to annotate date columns

    **Tests (test_dates.py) -- be comprehensive, dates are a critical path:**
    - sas_date_to_iso: known value conversions, None/NaN handling, edge cases (day 0 = 1960-01-01)
    - sas_datetime_to_iso: known value from Fakedata (1964217600.0), None/NaN, midnight times
    - parse_string_date_to_iso: all supported formats, partial dates, empty/None input
    - format_partial_iso8601: year only, year-month, full date, full datetime, None year
    - detect_date_format: samples of each format type
    - CRITICAL TEST: Verify sas_datetime_to_iso(1964217600.0) produces a date in 2022 range (not 5000+). This catches the DATE vs DATETIME confusion.
  </action>
  <verify>Run: pytest tests/test_transforms/test_dates.py -v</verify>
  <done>All date conversion functions handle SAS numeric dates, string dates, and partial dates correctly. Critical DATETIME vs DATE distinction verified with real sample data values.</done>
</task>

<task type="auto">
  <name>Task 2: Implement USUBJID generation and cross-domain validation</name>
  <files>
    src/astraea/transforms/usubjid.py
    tests/test_transforms/test_usubjid.py
  </files>
  <action>
    Implement USUBJID utilities per SDTM-IG rules.

    **generate_usubjid(studyid: str, siteid: str, subjid: str, delimiter: str = "-") -> str:**
    - Concatenate: f"{studyid}{delimiter}{siteid}{delimiter}{subjid}"
    - Per SDTM-IG: USUBJID must uniquely identify subject across all sponsor studies
    - Strip whitespace from components before concatenation

    **extract_usubjid_components(usubjid: str, delimiter: str = "-") -> dict[str, str]:**
    - Parse a USUBJID back into components: {"studyid": ..., "siteid": ..., "subjid": ...}
    - Handle case where more than 2 delimiters exist (e.g., "STUDY-01-SITE-001-SUBJ-01"): studyid is everything before first delimiter? No -- this is study-specific. For now, assume 3-part format with exactly 2 delimiters. Log warning if format differs.

    **generate_usubjid_column(df: pd.DataFrame, studyid_col: str, siteid_col: str, subjid_col: str, studyid_value: str | None = None, delimiter: str = "-") -> pd.Series:**
    - Generate USUBJID for an entire DataFrame
    - If studyid_value is provided, use that constant (common: STUDYID is same for all rows)
    - Otherwise use studyid_col values
    - Returns a pandas Series of USUBJID strings

    **validate_usubjid_consistency(datasets: dict[str, pd.DataFrame], usubjid_col: str = "USUBJID") -> list[str]:**
    - Check all USUBJIDs in non-DM domains exist in DM
    - Check no duplicate USUBJIDs within DM
    - Check USUBJID format is consistent (same delimiter, same component count) across all domains
    - Return list of error messages (empty = valid)

    **Tests (test_usubjid.py):**
    - generate_usubjid: basic concatenation, custom delimiter, whitespace stripping
    - extract_usubjid_components: valid 3-part, edge cases
    - generate_usubjid_column: with constant studyid, with column studyid
    - validate_usubjid_consistency: valid set returns empty errors, orphan USUBJID returns error, duplicate in DM returns error, missing DM returns error
  </action>
  <verify>Run: pytest tests/test_transforms/test_usubjid.py -v</verify>
  <done>USUBJID generation produces correct format. Cross-domain validation catches orphans and duplicates. All tests pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/test_transforms/ -v` all pass
- `python -c "from astraea.transforms.dates import sas_datetime_to_iso; print(sas_datetime_to_iso(1964217600.0))"` prints a 2022 date (not year 5000+)
- `python -c "from astraea.transforms.dates import parse_string_date_to_iso; print(parse_string_date_to_iso('30 Mar 2022'))"` prints "2022-03-30"
- `python -c "from astraea.transforms.dates import format_partial_iso8601; print(format_partial_iso8601(2023, 3, None))"` prints "2023-03"
- `python -c "from astraea.transforms.usubjid import generate_usubjid; print(generate_usubjid('301', '04401', '01'))"` prints "301-04401-01"
</verification>

<success_criteria>
- Date converter handles SAS DATE (days), SAS DATETIME (seconds), and string formats correctly
- Partial dates produce truncated ISO 8601 per SDTM-IG rules (no imputation)
- USUBJID generation and cross-domain validation work correctly
- All transforms are pure functions with no LLM dependency
- Comprehensive test coverage with real sample data values
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
