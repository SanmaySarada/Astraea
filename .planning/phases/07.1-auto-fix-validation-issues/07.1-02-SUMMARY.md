---
phase: 07.1-auto-fix-validation-issues
plan: 02
subsystem: validation
tags: [fix-loop, validation, autofix, audit-trail, xpt-output]
completed: 2026-02-28
duration: ~3 min

dependency_graph:
  requires: [07.1-01]
  provides: [FixLoopEngine, FixLoopResult, IterationResult, format_needs_human_report]
  affects: [07.1-03]

tech_stack:
  added: []
  patterns: [validate-fix-revalidate loop, in-place domain dict mutation, pyreadstat direct XPT write]

key_files:
  created:
    - src/astraea/validation/fix_loop.py
    - tests/unit/validation/test_fix_loop.py
  modified: []

decisions:
  - id: D-07.1-02-01
    decision: "FixLoopEngine updates domains dict in-place (replacing DataFrames and specs) so each iteration builds on previous fixes"
  - id: D-07.1-02-02
    decision: "_write_fixed_datasets uses pyreadstat.write_xport directly (not xpt_writer.write_xpt_v5) to avoid strict validation blocking partially-fixed datasets"
  - id: D-07.1-02-03
    decision: "apply_fixes returns 3-tuple (df, spec, actions) per 07.1-01 -- loop engine handles spec updates alongside DataFrame updates"

metrics:
  tests_added: 11
  tests_passing: 11
  files_created: 2
  lines_of_code: ~396 (fix_loop.py) + ~524 (tests)
---

# Phase 7.1 Plan 02: Validate-Fix-Revalidate Loop Engine Summary

FixLoopEngine that orchestrates up to 3 iterations of validate-classify-fix-revalidate, with convergence detection, accumulated audit trail, XPT output, and needs-human report formatting.

## What Was Built

### FixLoopEngine (`src/astraea/validation/fix_loop.py`)

1. **IterationResult Pydantic model** -- per-iteration breakdown with issues_found, auto_fixed, remaining_auto_fixable, needs_human, and fix_actions.

2. **FixLoopResult Pydantic model** -- comprehensive result with iterations_run, max_iterations, converged flag, total_fixed, remaining_issues, needs_human_issues, all_fix_actions audit trail, iteration_details, and final_report.

3. **FixLoopEngine class** with:
   - `__init__` taking engine, auto_fixer, max_iterations (default 3)
   - `run_fix_loop()` -- the core loop: validate all domains, classify issues, apply auto-fixes per domain, repeat until convergence or max iterations, run final validation, optionally write XPTs and audit trail

4. **`_write_fixed_datasets`** helper -- writes each domain's DataFrame to `{domain.lower()}.xpt` using pyreadstat.write_xport with labels from the spec's variable_mappings.

5. **`_write_audit_trail`** helper -- serializes all FixActions to `autofix_audit.json` via model_dump().

6. **`format_needs_human_report`** helper -- groups needs-human IssueClassifications by domain, formats with rule ID, variable, message, reason, and suggested fix for CLI display.

### Test Coverage (`tests/unit/validation/test_fix_loop.py`)

- 2 convergence tests (no auto-fixable issues, fixable issue gets resolved)
- 1 max iterations cap test (mock fixer that never resolves)
- 1 fix action accumulation test (total_fixed matches all_fix_actions length)
- 1 needs-human classification test
- 1 iteration details population test
- 1 final report correctness test (fewer errors after fix loop)
- 2 format_needs_human_report tests (empty and populated)
- 2 output writing tests (XPT file existence, audit JSON structure)

## Decisions Made

1. **D-07.1-02-01**: The domains dict is mutated in-place during the loop -- each iteration replaces the (df, spec) tuple for fixed domains. This is intentional so subsequent iterations validate against the fixed state.
2. **D-07.1-02-02**: `_write_fixed_datasets` uses pyreadstat.write_xport directly rather than the strict xpt_writer.write_xpt_v5, because partially-fixed datasets may still have remaining validation issues that would block the strict writer.
3. **D-07.1-02-03**: The AutoFixer.apply_fixes returns a 3-tuple (df, spec, actions) since label truncation modifies the spec. The loop engine updates both the DataFrame and spec in the domains dict.

## Deviations from Plan

None -- plan executed exactly as written.

## Next Phase Readiness

Plan 07.1-03 (CLI integration and end-to-end wiring) can proceed. It will use FixLoopEngine.run_fix_loop() as the backend for the `astraea autofix` CLI command.
