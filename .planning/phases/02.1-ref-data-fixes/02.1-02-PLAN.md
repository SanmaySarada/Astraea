---
phase: 02.1-ref-data-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/transforms/dates.py
  - tests/test_transforms/test_dates.py
autonomous: true

must_haves:
  truths:
    - "SAS numeric date 22738.9999 converts to the correct day (not off-by-one)"
    - "Invalid dates like Feb 30, month 13, day 32 are rejected and return empty string"
    - "Partial date 'UN UNK 2004' converts to '2004'"
    - "Datetime string '16 MAY 2022 21:30' converts to '2022-05-16T21:30'"
    - "All existing date conversion tests still pass"
  artifacts:
    - path: "src/astraea/transforms/dates.py"
      provides: "Fixed date conversion with round(), validation, UN UNK, datetime string support"
    - path: "tests/test_transforms/test_dates.py"
      provides: "Tests for each fix"
  key_links:
    - from: "src/astraea/transforms/dates.py"
      to: "src/astraea/profiling/profiler.py"
      via: "imported for date detection"
      pattern: "from astraea.transforms"
---

<objective>
Fix 4 date conversion bugs: use round() instead of int() for SAS numeric conversion, add date range validation, add "UN UNK" partial date pattern, and add datetime string pattern support.

Purpose: Date conversion is used in every SDTM domain. Off-by-one day errors from int() truncation, acceptance of invalid dates like Feb 30, and inability to parse common clinical date patterns will produce incorrect SDTM output in Phase 3.

Output: Corrected dates.py with all 4 fixes + comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PHASE2_AUDIT.md
@src/astraea/transforms/dates.py
@tests/test_transforms/test_dates.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix SAS numeric rounding, add date validation, add new patterns</name>
  <files>src/astraea/transforms/dates.py</files>
  <action>
  Apply these 4 fixes to dates.py:

  **Fix 1: round() instead of int() (lines 77 and 107)**
  - In `sas_date_to_iso`: Change `days = int(sas_numeric)` to `days = round(sas_numeric)`. This ensures 22738.9999 rounds to 22739 (correct day) instead of truncating to 22738 (wrong day).
  - In `sas_datetime_to_iso`: Change `seconds = int(sas_numeric)` to `seconds = round(sas_numeric)`. Same reasoning for fractional seconds.

  **Fix 2: Add date range validation helper**
  Add a private function `_validate_date_components(year, month, day)` that returns True if the date is valid:
  - month must be 1-12 (if provided)
  - day must be 1-31 (if provided) AND must be valid for the given month/year (use calendar.monthrange or try/except with datetime.date)
  - year must be reasonable (1800-2100 range)

  Then call this validation in:
  - `parse_string_date_to_iso`: After extracting day/month/year from any pattern, validate before formatting. If invalid, log warning and return "".
  - `format_partial_iso8601`: After receiving year/month/day, validate. If invalid, log warning and return "".

  **Fix 3: Add "UN UNK" partial date pattern**
  Add a new regex pattern BEFORE the existing DD Mon YYYY pattern:
  ```python
  _PATTERN_UN_UNK_YYYY = re.compile(
      r"^\s*(?:un|unk)\s+(?:un|unk)\s+(\d{4})\s*$",
      re.IGNORECASE,
  )
  ```
  Also add pattern for unknown day only:
  ```python
  _PATTERN_UN_MON_YYYY = re.compile(
      r"^\s*(?:un|unk)\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{4})\s*$",
      re.IGNORECASE,
  )
  ```
  In `parse_string_date_to_iso`, check these patterns before DD Mon YYYY:
  - "UN UNK 2004" or "UNK UNK 2004" -> return "2004"
  - "UN Mar 2022" or "UNK Mar 2022" -> return "2022-03"

  **Fix 4: Add datetime string pattern**
  Add a regex for "DD MON YYYY HH:MM" format:
  ```python
  _PATTERN_DD_MON_YYYY_HHMM = re.compile(
      r"^\s*(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{4})\s+(\d{1,2}):(\d{2})\s*$",
      re.IGNORECASE,
  )
  ```
  In `parse_string_date_to_iso`, check this pattern BEFORE the DD Mon YYYY pattern (since it's more specific). Parse day, month, year, hour, minute and return "YYYY-MM-DDTHH:MM" format. Apply date validation to the extracted components.

  **Import calendar** at the top if needed for monthrange validation (or use try/except with datetime.date constructor which is cleaner).
  </action>
  <verify>
  Run quick spot checks:
  ```
  python3 -c "
  from astraea.transforms.dates import sas_date_to_iso, parse_string_date_to_iso
  # Fix 1: round not truncate
  assert sas_date_to_iso(22738.9999) == '2022-03-30', f'Got {sas_date_to_iso(22738.9999)}'
  # Fix 2: invalid date rejected
  assert parse_string_date_to_iso('30 Feb 2022') == '', f'Got {parse_string_date_to_iso(\"30 Feb 2022\")}'
  # Fix 3: UN UNK pattern
  assert parse_string_date_to_iso('UN UNK 2004') == '2004', f'Got {parse_string_date_to_iso(\"UN UNK 2004\")}'
  # Fix 4: datetime string
  assert parse_string_date_to_iso('16 MAY 2022 21:30') == '2022-05-16T21:30', f'Got {parse_string_date_to_iso(\"16 MAY 2022 21:30\")}'
  print('ALL SPOT CHECKS PASSED')
  "
  ```
  </verify>
  <done>All 4 date fixes applied and verified with spot checks.</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for all date fixes</name>
  <files>tests/test_transforms/test_dates.py</files>
  <action>
  Add new test classes/methods to the existing test file:

  **Test round() fix:**
  - `test_sas_date_fractional_rounds_up`: sas_date_to_iso(22738.9999) == "2022-03-30"
  - `test_sas_date_fractional_rounds_down`: sas_date_to_iso(22738.4) == "2022-03-29"
  - `test_sas_date_exact_integer_unchanged`: sas_date_to_iso(22739.0) == "2022-03-30"
  - `test_sas_datetime_fractional_rounds`: sas_datetime_to_iso(1964217600.7) -- verify correct time (round to 1964217601 seconds)
  - `test_sas_datetime_exact_unchanged`: sas_datetime_to_iso(1964217600.0) == "2022-03-15T00:00:00"

  **Test date validation:**
  - `test_invalid_feb_30_returns_empty`: parse_string_date_to_iso("30 Feb 2022") == ""
  - `test_invalid_month_13_returns_empty`: format_partial_iso8601(2022, 13, 1) == ""
  - `test_invalid_day_32_returns_empty`: parse_string_date_to_iso("32 Mar 2022") == ""
  - `test_valid_feb_29_leap_year`: parse_string_date_to_iso("29 Feb 2024") == "2024-02-29"
  - `test_invalid_feb_29_non_leap`: parse_string_date_to_iso("29 Feb 2023") == ""
  - `test_valid_jan_31`: parse_string_date_to_iso("31 Jan 2022") == "2022-01-31"
  - `test_invalid_apr_31`: parse_string_date_to_iso("31 Apr 2022") == ""
  - `test_slash_date_invalid_rejected`: parse_string_date_to_iso("30/02/2022") == ""

  **Test UN UNK patterns:**
  - `test_un_unk_yyyy`: parse_string_date_to_iso("UN UNK 2004") == "2004"
  - `test_unk_unk_yyyy`: parse_string_date_to_iso("UNK UNK 2004") == "2004"
  - `test_un_unk_yyyy_lowercase`: parse_string_date_to_iso("un unk 2004") == "2004"
  - `test_un_mon_yyyy`: parse_string_date_to_iso("UN Mar 2022") == "2022-03"
  - `test_unk_mon_yyyy`: parse_string_date_to_iso("UNK Mar 2022") == "2022-03"

  **Test datetime string pattern:**
  - `test_dd_mon_yyyy_hhmm`: parse_string_date_to_iso("16 MAY 2022 21:30") == "2022-05-16T21:30"
  - `test_dd_mon_yyyy_hhmm_lowercase`: parse_string_date_to_iso("16 may 2022 21:30") == "2022-05-16T21:30"
  - `test_dd_mon_yyyy_hhmm_single_digit_hour`: parse_string_date_to_iso("5 Jun 2022 9:15") == "2022-06-05T09:15"
  - `test_dd_mon_yyyy_hhmm_midnight`: parse_string_date_to_iso("1 Jan 2023 0:00") == "2023-01-01T00:00"

  Run the full test suite to confirm no regressions.
  </action>
  <verify>Run: `cd /Users/sanmaysarada/Astraea-SDTM && python3 -m pytest tests/test_transforms/test_dates.py -v` -- all tests pass including new ones.</verify>
  <done>All date fix tests pass. No regressions in existing tests.</done>
</task>

</tasks>

<verification>
1. `python3 -m pytest tests/ -x -q` -- all 389+ tests pass
2. Spot checks for each fix type confirmed in Task 1 verify step
</verification>

<success_criteria>
- round() used for SAS numeric conversion (no more int() truncation)
- Invalid dates (Feb 30, month 13, etc.) rejected with empty string return
- "UN UNK YYYY" and "UN Mon YYYY" partial date patterns parse correctly
- "DD MON YYYY HH:MM" datetime strings parse to ISO 8601
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-ref-data-fixes/02.1-02-SUMMARY.md`
</output>
