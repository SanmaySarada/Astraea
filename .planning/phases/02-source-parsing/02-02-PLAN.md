---
phase: 02-source-parsing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/astraea/parsing/__init__.py
  - src/astraea/parsing/pdf_extractor.py
  - src/astraea/parsing/ecrf_parser.py
  - tests/test_parsing/__init__.py
  - tests/test_parsing/test_pdf_extractor.py
  - tests/test_parsing/test_ecrf_parser.py
autonomous: true

must_haves:
  truths:
    - "System extracts eCRF PDF pages to Markdown with table structure preserved"
    - "System groups extracted pages by form name using the 'Form: <name>' header pattern"
    - "System sends each form's Markdown to Claude and receives structured ECRFForm objects"
    - "System handles multi-page forms by concatenating pages with the same form header"
  artifacts:
    - path: "src/astraea/parsing/pdf_extractor.py"
      provides: "extract_ecrf_pages() and group_pages_by_form() functions"
      contains: "def extract_ecrf_pages"
    - path: "src/astraea/parsing/ecrf_parser.py"
      provides: "parse_ecrf() orchestrator and extract_form_fields() per-form extractor"
      contains: "def parse_ecrf"
  key_links:
    - from: "src/astraea/parsing/pdf_extractor.py"
      to: "pymupdf4llm"
      via: "pymupdf4llm.to_markdown()"
      pattern: "to_markdown"
    - from: "src/astraea/parsing/ecrf_parser.py"
      to: "src/astraea/llm/client.py"
      via: "AstraeaLLMClient.parse()"
      pattern: "client\\.parse"
    - from: "src/astraea/parsing/ecrf_parser.py"
      to: "src/astraea/models/ecrf.py"
      via: "Returns ECRFExtractionResult"
      pattern: "ECRFExtractionResult"
---

<objective>
Build the eCRF PDF extraction pipeline: extract PDF to Markdown with pymupdf4llm, group pages by form, then use Claude structured output to parse each form into ECRFForm/ECRFField models.

Purpose: Fulfills ECRF-01 (parse PDF, extract form metadata), ECRF-02 (extract field-level metadata), and ECRF-04 (handle variable layouts, not hardcoded).
Output: parsing/pdf_extractor.py, parsing/ecrf_parser.py with full test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-source-parsing/02-RESEARCH.md
@src/astraea/models/ecrf.py
@src/astraea/llm/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PDF Extractor (Deterministic)</name>
  <files>
    src/astraea/parsing/__init__.py
    src/astraea/parsing/pdf_extractor.py
    tests/test_parsing/__init__.py
    tests/test_parsing/test_pdf_extractor.py
  </files>
  <action>
**src/astraea/parsing/__init__.py:** Export key functions.

**src/astraea/parsing/pdf_extractor.py:** Deterministic PDF extraction layer (no LLM calls).

`extract_ecrf_pages(pdf_path: str | Path) -> list[dict]`:
- Calls `pymupdf4llm.to_markdown(str(pdf_path), page_chunks=True, table_strategy="lines_strict", show_progress=False)`
- Returns raw list of page dicts from pymupdf4llm
- Log number of pages extracted with loguru

`group_pages_by_form(pages: list[dict]) -> dict[str, list[tuple[int, str]]]`:
- Iterates through pages, detecting form headers via regex: `r"Form:\s*(.+?)(?:\n|$)"`
- Groups pages by form name. Each form maps to a list of (page_number, page_text) tuples.
- Multiple pages with same form header are grouped together (handles multi-page forms per Pitfall 2)
- Pages before any form header go into "HEADER" group
- Returns dict of form_name -> [(page_num, text), ...]
- Log form count and pages per form

`get_form_names(pages: list[dict]) -> list[str]`:
- Returns ordered unique form names found in the pages
- Utility function for CLI display

**Tests (test_pdf_extractor.py):**
- Test group_pages_by_form with mock page data containing "Form: Demographics" headers
- Test multi-page form grouping (3 pages with same "Form: Adverse Events" header)
- Test pages before any form header go to "HEADER"
- Test get_form_names returns unique ordered names
- Integration test: if ECRF.pdf exists, run extract_ecrf_pages and verify it returns >100 pages (mark with @pytest.mark.skipif for CI)
  </action>
  <verify>pytest tests/test_parsing/test_pdf_extractor.py -v</verify>
  <done>PDF extractor reads ECRF.pdf to Markdown, groups pages by form name. Unit tests pass. If ECRF.pdf is present, integration test extracts real pages.</done>
</task>

<task type="auto">
  <name>Task 2: eCRF Parser (LLM-Based Structured Extraction)</name>
  <files>
    src/astraea/parsing/ecrf_parser.py
    tests/test_parsing/test_ecrf_parser.py
  </files>
  <action>
**src/astraea/parsing/ecrf_parser.py:** LLM-based eCRF parsing that converts Markdown form text to structured ECRFForm models.

`ECRF_EXTRACTION_PROMPT`: System prompt instructing Claude to extract from the FIELD TABLE section only (per Research Pitfall 3). Include:
- Instruction to look for "Field Name Data Type SAS Label Units Values Include Field OID" header
- Instruction that field names are SAS variable names (uppercase, no spaces, max 8 chars)
- Instruction to join field names split across lines
- Instruction to extract coded_values as dict (e.g., "Y = Yes, N = No" -> {"Y": "Yes", "N": "No"})
- Instruction to return field_oid (usually same as field_name)

`extract_form_fields(client: AstraeaLLMClient, form_name: str, form_text: str) -> ECRFForm`:
- Calls client.parse() with model="claude-sonnet-4-20250514", temperature=0.2, max_tokens=4096
- Uses ECRFForm as the output_format (Pydantic structured output)
- The user message contains the form_text formatted into the extraction prompt
- Returns the parsed ECRFForm
- If form_text is very short (< 50 chars), return an ECRFForm with empty fields list (skip trivial pages)

`parse_ecrf(pdf_path: str | Path, client: AstraeaLLMClient | None = None) -> ECRFExtractionResult`:
- Orchestrator function. If client is None, create a new AstraeaLLMClient.
- Calls extract_ecrf_pages() then group_pages_by_form()
- For each form, concatenates all page texts, then calls extract_form_fields()
- Skips "HEADER" and "UNKNOWN" form groups
- Collects all ECRFForm results into ECRFExtractionResult
- Logs progress: "Parsing form X of Y: <form_name>"
- Returns ECRFExtractionResult with source_pdf, timestamp, total_fields computed

`save_extraction(result: ECRFExtractionResult, output_path: str | Path) -> None`:
- Saves ECRFExtractionResult as JSON to disk for caching (per Research Pattern 4)
- Uses result.model_dump_json(indent=2)

`load_extraction(path: str | Path) -> ECRFExtractionResult`:
- Loads cached ECRFExtractionResult from JSON file
- Uses ECRFExtractionResult.model_validate_json()

**Tests (test_ecrf_parser.py):**
- Test extract_form_fields with mocked LLM client (mock client.parse() to return a known ECRFForm)
- Test parse_ecrf orchestrator with mocked pdf_extractor and mocked LLM client
- Test save_extraction and load_extraction round-trip with a fixture ECRFExtractionResult
- Test short form_text (<50 chars) returns empty fields list
- Do NOT require ANTHROPIC_API_KEY for tests
  </action>
  <verify>pytest tests/test_parsing/ -v</verify>
  <done>eCRF parser can extract structured form/field metadata from PDF via Claude. All unit tests pass with mocked LLM. Cache save/load works.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_parsing/ -v` -- all tests pass
2. `python -c "from astraea.parsing.pdf_extractor import extract_ecrf_pages, group_pages_by_form; print('PDF extractor OK')"` -- imports work
3. `python -c "from astraea.parsing.ecrf_parser import parse_ecrf, extract_form_fields; print('eCRF parser OK')"` -- imports work
4. `ruff check src/astraea/parsing/` -- no lint errors
</verification>

<success_criteria>
- PDF extractor reads any eCRF PDF to page-level Markdown chunks
- Pages are correctly grouped by "Form: <name>" headers
- Multi-page forms are concatenated before LLM processing
- eCRF parser sends each form to Claude and receives structured ECRFForm objects
- Extraction results can be cached to JSON and loaded back
- All unit tests pass without requiring an API key
</success_criteria>

<output>
After completion, create `.planning/phases/02-source-parsing/02-02-SUMMARY.md`
</output>
