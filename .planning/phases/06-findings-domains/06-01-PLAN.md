---
phase: 06-findings-domains
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/execution/transpose.py
  - src/astraea/execution/suppqual.py
  - src/astraea/models/suppqual.py
  - tests/unit/execution/test_transpose.py
  - tests/unit/execution/test_suppqual.py
autonomous: true

must_haves:
  truths:
    - "TRANSPOSE handler converts wide DataFrames to tall SDTM Findings format via pandas.melt()"
    - "SUPPQUAL generator produces referentially-intact supplemental qualifier records from parent domain data"
    - "TRANSPOSE handler is registered in PATTERN_HANDLERS and integrated with DatasetExecutor"
  artifacts:
    - path: "src/astraea/execution/transpose.py"
      provides: "TransposeSpec model and execute_transpose function using pandas.melt()"
      exports: ["TransposeSpec", "execute_transpose"]
    - path: "src/astraea/execution/suppqual.py"
      provides: "Deterministic SUPPQUAL generator with referential integrity validation"
      exports: ["SuppVariable", "generate_suppqual", "validate_suppqual_integrity"]
    - path: "src/astraea/models/suppqual.py"
      provides: "Pydantic model for SUPPQUAL variable specification"
      exports: ["SuppVariable"]
    - path: "tests/unit/execution/test_transpose.py"
      provides: "Unit tests for transpose handler"
    - path: "tests/unit/execution/test_suppqual.py"
      provides: "Unit tests for SUPPQUAL generator"
  key_links:
    - from: "src/astraea/execution/transpose.py"
      to: "src/astraea/execution/pattern_handlers.py"
      via: "TRANSPOSE registered in PATTERN_HANDLERS dict"
      pattern: "PATTERN_HANDLERS.*TRANSPOSE"
    - from: "src/astraea/execution/suppqual.py"
      to: "src/astraea/models/mapping.py"
      via: "Uses DomainMappingSpec for parent domain info"
      pattern: "DomainMappingSpec"
---

<objective>
Build the TRANSPOSE pattern handler and deterministic SUPPQUAL generator -- the two foundational components all Findings domains and supplemental datasets depend on.

Purpose: The TRANSPOSE handler enables wide-to-tall conversion (the hardest SDTM transformation). The SUPPQUAL generator produces supplemental qualifier datasets with guaranteed referential integrity. Both are prerequisites for LB, EG, PE domains and their SUPP datasets.

Output: Two new modules (transpose.py, suppqual.py) with full unit tests, registered in the execution pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-findings-domains/06-RESEARCH.md
@src/astraea/execution/pattern_handlers.py
@src/astraea/execution/executor.py
@src/astraea/models/mapping.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TRANSPOSE handler and TransposeSpec model</name>
  <files>
    src/astraea/execution/transpose.py
    src/astraea/execution/pattern_handlers.py
    tests/unit/execution/test_transpose.py
  </files>
  <action>
Create `src/astraea/execution/transpose.py` with:

1. **TransposeSpec** Pydantic model:
   - `id_vars: list[str]` -- columns to keep as-is (USUBJID, VISITNUM, date cols)
   - `value_vars: list[str]` -- columns to unpivot (test result columns)
   - `testcd_mapping: dict[str, str]` -- column name -> TESTCD value
   - `test_mapping: dict[str, str]` -- column name -> TEST label
   - `unit_mapping: dict[str, str]` -- column name -> unit string (optional, can have None values)
   - `result_var: str` -- target for ORRES (e.g., "LBORRES")
   - `testcd_var: str` -- target for TESTCD (e.g., "LBTESTCD")
   - `test_var: str` -- target for TEST (e.g., "LBTEST")
   - `unit_var: str` -- target for ORRESU (e.g., "LBORRESU")

2. **execute_transpose(df: pd.DataFrame, spec: TransposeSpec) -> pd.DataFrame**:
   - Uses `pd.melt()` with id_vars and value_vars
   - Maps source column names to TESTCD, TEST, and unit values via the spec dictionaries
   - Drops the intermediate `_source_col` column
   - Drops rows where the result value is NaN/None (test not performed)
   - Returns the tall DataFrame

3. **handle_transpose(df: pd.DataFrame, mapping: VariableMapping, **kwargs) -> pd.Series**:
   - This is a STUB that logs a warning: "TRANSPOSE mappings are handled at the DataFrame level by execute_transpose(), not per-variable"
   - Returns an empty Series. The actual transpose is called by the executor pre-step, not per-variable.
   - Register `handle_transpose` in `PATTERN_HANDLERS` dict in `pattern_handlers.py` for `MappingPattern.TRANSPOSE`

Create `tests/unit/execution/test_transpose.py` with tests:
- Test basic wide-to-tall with 3 test columns, 2 subjects, 3 visits -> verify row count = 3*2*3 = 18 (minus any null results)
- Test that null result values are dropped
- Test that TESTCD, TEST, and unit columns are correctly mapped
- Test with mixed null units (some tests have units, some do not)
- Test empty DataFrame input returns empty DataFrame
- Test single column transpose
- Test TransposeSpec validation (Pydantic)
  </action>
  <verify>
Run `pytest tests/unit/execution/test_transpose.py -v` -- all tests pass.
Run `ruff check src/astraea/execution/transpose.py` -- no lint errors.
  </verify>
  <done>
TransposeSpec model created. execute_transpose function converts wide DataFrames to tall format via pandas.melt(). handle_transpose stub registered in PATTERN_HANDLERS. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: SUPPQUAL generator with referential integrity</name>
  <files>
    src/astraea/execution/suppqual.py
    src/astraea/models/suppqual.py
    tests/unit/execution/test_suppqual.py
  </files>
  <action>
Create `src/astraea/models/suppqual.py` with:

1. **SuppVariable** Pydantic model:
   - `qnam: str` -- SUPPQUAL variable name, max 8 chars, alphanumeric, validated
   - `qlabel: str` -- variable label, max 40 chars
   - `source_col: str` -- source column name in parent DataFrame
   - `qorig: str` -- origin: "CRF", "ASSIGNED", "DERIVED", "PROTOCOL"
   - `qeval: str = ""` -- evaluator (optional, usually empty or "INVESTIGATOR")

Create `src/astraea/execution/suppqual.py` with:

1. **generate_suppqual(parent_df, domain, study_id, supp_variables) -> pd.DataFrame**:
   - `parent_df: pd.DataFrame` -- finalized parent domain DataFrame (must have USUBJID and {domain}SEQ)
   - `domain: str` -- parent domain code (e.g., "AE", "LB")
   - `study_id: str` -- study identifier
   - `supp_variables: list[SuppVariable]` -- list of supplemental variables to extract
   - For each row in parent_df, for each SuppVariable, if the source column value is non-null and non-empty:
     - Create a SUPPQUAL record with STUDYID, RDOMAIN, USUBJID, IDVAR={domain}SEQ, IDVARVAL=str(int(row[{domain}SEQ])), QNAM (truncated to 8 chars), QLABEL (truncated to 40 chars), QVAL=str(val), QORIG, QEVAL
   - Return DataFrame with columns: STUDYID, RDOMAIN, USUBJID, IDVAR, IDVARVAL, QNAM, QLABEL, QVAL, QORIG, QEVAL
   - If no records, return empty DataFrame with correct columns

2. **validate_suppqual_integrity(supp_df, parent_df, domain) -> list[str]**:
   - Validates every (RDOMAIN, USUBJID, IDVAR, IDVARVAL) in supp_df points to an existing parent record
   - Returns list of error messages (empty = valid)
   - Checks: RDOMAIN matches domain, IDVAR matches {domain}SEQ, every IDVARVAL exists in parent_df[{domain}SEQ]
   - Checks: no duplicate QNAM within same (USUBJID, IDVARVAL)

Create `tests/unit/execution/test_suppqual.py` with tests:
- Test basic SUPPQUAL generation with 3 parent rows, 2 supp variables -> verify 6 records (assuming all non-null)
- Test null/empty values are skipped (no SUPPQUAL record for null source values)
- Test QNAM truncation to 8 chars
- Test QLABEL truncation to 40 chars
- Test referential integrity validation passes on valid data
- Test referential integrity validation catches orphaned records (IDVARVAL not in parent)
- Test referential integrity validation catches duplicate QNAM per subject+seq
- Test empty parent DataFrame -> empty SUPPQUAL
- Test SuppVariable validation (QNAM too long, invalid chars)
  </action>
  <verify>
Run `pytest tests/unit/execution/test_suppqual.py -v` -- all tests pass.
Run `ruff check src/astraea/execution/suppqual.py src/astraea/models/suppqual.py` -- no lint errors.
Run `pytest tests/ -x -q` -- full suite still passes.
  </verify>
  <done>
SuppVariable model with validation created. generate_suppqual produces referentially-intact SUPPQUAL DataFrames. validate_suppqual_integrity catches orphaned records and duplicate QNAMs. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/unit/execution/test_transpose.py tests/unit/execution/test_suppqual.py -v` -- all pass
- `ruff check src/astraea/execution/transpose.py src/astraea/execution/suppqual.py src/astraea/models/suppqual.py` -- clean
- `pytest tests/ -x -q` -- full suite (1100+ tests) still passes
- TRANSPOSE registered in PATTERN_HANDLERS dictionary
</verification>

<success_criteria>
1. TransposeSpec + execute_transpose converts any wide DataFrame to tall SDTM format
2. SUPPQUAL generator produces valid supplemental qualifier records from parent domain data
3. Referential integrity validation catches all orphan/duplicate issues
4. Both modules have comprehensive unit tests
5. Full test suite remains green
</success_criteria>

<output>
After completion, create `.planning/phases/06-findings-domains/06-01-SUMMARY.md`
</output>
