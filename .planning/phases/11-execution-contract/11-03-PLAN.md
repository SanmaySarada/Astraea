---
phase: 11-execution-contract
plan: 03
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - src/astraea/mapping/prompts.py
  - src/astraea/execution/executor.py
  - tests/unit/mapping/test_prompts_vocabulary.py
  - tests/unit/execution/test_executor_resolution.py
autonomous: true

must_haves:
  truths:
    - "LLM system prompt enumerates the exact derivation rule vocabulary with usage examples"
    - "LLM prompt instructs to use actual SAS column names from source profiles, not eCRF names"
    - "Executor resolves eCRF column names to actual SAS column names before pattern handlers run"
    - "Executor passes column_aliases and cross_domain_dfs to pattern handlers via kwargs"
  artifacts:
    - path: "src/astraea/mapping/prompts.py"
      provides: "Constrained derivation rule vocabulary in system prompt"
      contains: "GENERATE_USUBJID"
    - path: "src/astraea/execution/executor.py"
      provides: "Column name resolution before pattern handler dispatch"
      contains: "column_aliases"
  key_links:
    - from: "src/astraea/mapping/prompts.py"
      to: "src/astraea/execution/pattern_handlers.py"
      via: "Shared derivation rule vocabulary"
      pattern: "GENERATE_USUBJID|CONCAT|ISO8601_DATE|RACE_CHECKBOX"
    - from: "src/astraea/execution/executor.py"
      to: "src/astraea/execution/pattern_handlers.py"
      via: "kwargs passing column_aliases and cross_domain_dfs"
      pattern: "column_aliases"
---

<objective>
Constrain the LLM mapping prompt to only emit recognized derivation rules, and add column name resolution in the executor so eCRF field names resolve to actual SAS column names before pattern handlers run.

Purpose: The prompt constraint ensures the LLM only generates executable rules (closing the contract gap). The column resolution ensures SSUBJID -> Subject, SSITENUM -> SiteNumber mappings work.
Output: Updated system prompt with derivation vocabulary, executor with column resolution, tests for both.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/MASTER_AUDIT.md
@.planning/phases/11-execution-contract/11-RESEARCH.md
@.planning/phases/11-execution-contract/11-02-SUMMARY.md
@src/astraea/mapping/prompts.py
@src/astraea/execution/executor.py
@src/astraea/execution/pattern_handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Constrain LLM prompt with derivation rule vocabulary</name>
  <files>
    src/astraea/mapping/prompts.py
    tests/unit/mapping/test_prompts_vocabulary.py
  </files>
  <action>
    1. In `src/astraea/mapping/prompts.py`, replace the vague derivation_rule instruction (lines 60-62) with a formal vocabulary section in MAPPING_SYSTEM_PROMPT:

    Replace:
    ```
    - For derivation_rule, use a pseudo-code DSL describing the transformation \
    logic (e.g., ASSIGN("DM"), DIRECT(dm.AGE), CONCAT(STUDYID, "-", SITEID, \
    "-", SUBJID)).
    ```

    With a new section (add after the SUPPQUAL rules, before the closing triple-quote):
    ```
    ## Derivation Rule Vocabulary

    The derivation_rule field MUST use one of these recognized keywords. \
    The execution engine will reject any rule not in this list:

    | Keyword | Usage | Example |
    |---------|-------|---------|
    | GENERATE_USUBJID | USUBJID construction from STUDYID + SITEID + SUBJID | GENERATE_USUBJID |
    | CONCAT | Concatenate column values and literals | CONCAT(col1, '-', col2) |
    | ISO8601_DATE | Convert SAS numeric date to ISO 8601 | ISO8601_DATE(AESTDAT_INT) |
    | ISO8601_DATETIME | Convert SAS numeric datetime to ISO 8601 | ISO8601_DATETIME(EXDTTM_INT) |
    | ISO8601_PARTIAL_DATE | Build ISO date from year/month/day columns | ISO8601_PARTIAL_DATE(BRTHYR_YYYY) |
    | PARSE_STRING_DATE | Parse string date to ISO 8601 | PARSE_STRING_DATE(AESTDAT_RAW) |
    | MIN_DATE_PER_SUBJECT | Earliest date per USUBJID | MIN_DATE_PER_SUBJECT(EXSTDAT_INT) |
    | MAX_DATE_PER_SUBJECT | Latest date per USUBJID | MAX_DATE_PER_SUBJECT(EXENDAT_INT) |
    | RACE_CHECKBOX | Derive RACE from 0/1 checkbox columns | RACE_CHECKBOX(RACEAME, RACEASI, RACEWHI) |
    | NUMERIC_TO_YN | Convert 0/1 numeric to Y/N | NUMERIC_TO_YN(AESLIFE) |

    For ASSIGN and DIRECT patterns, no derivation_rule is needed -- use assigned_value \
    or source_variable directly.

    For LOOKUP_RECODE, specify the codelist_code -- no derivation_rule needed.

    Arguments MUST use actual SAS column names from the Source Dataset Profile above, \
    NOT eCRF field names or OID names. The column names shown in the profile sections \
    are the exact names available in the data.
    ```

    2. Also update the MAPPING_USER_INSTRUCTIONS to reinforce:
    After the line `- derivation_rule: pseudo-code DSL for the execution engine (if applicable)`:
    Change to: `- derivation_rule: must use a keyword from the Derivation Rule Vocabulary above`

    3. Write test `tests/unit/mapping/test_prompts_vocabulary.py`:
    - test_system_prompt_contains_vocabulary: Assert MAPPING_SYSTEM_PROMPT contains all 10 keywords
    - test_system_prompt_contains_column_name_instruction: Assert prompt contains "actual SAS column names"
    - test_user_instructions_reference_vocabulary: Assert MAPPING_USER_INSTRUCTIONS references the vocabulary
  </action>
  <verify>pytest tests/unit/mapping/test_prompts_vocabulary.py -xvs</verify>
  <done>LLM system prompt contains formal derivation rule vocabulary with all 10 keywords. Prompt instructs LLM to use actual SAS column names.</done>
</task>

<task type="auto">
  <name>Task 2: Add column name resolution to executor</name>
  <files>
    src/astraea/execution/executor.py
    tests/unit/execution/test_executor_resolution.py
  </files>
  <action>
    1. In `src/astraea/execution/executor.py`, in the `DatasetExecutor` class:

       a. Add a `_build_column_aliases` method that builds a column alias map from the merged DataFrame and profiling metadata:
       ```python
       def _build_column_aliases(self, df: pd.DataFrame) -> dict[str, str]:
           """Build alias map from eCRF/IRT names to actual SAS column names."""
           aliases: dict[str, str] = {}
           # EDC standard aliases
           edc_aliases = {
               "SSUBJID": "Subject",
               "SSITENUM": "SiteNumber",
               "SSITE": "Site",
               "SSITEGROUP": "SiteGroup",
           }
           for ecrf_name, sas_name in edc_aliases.items():
               if sas_name in df.columns:
                   aliases[ecrf_name] = sas_name
           return aliases
       ```

       b. In the `execute()` method, before the pattern handler loop, build column aliases and pass them as kwargs to every pattern handler call. Find where PATTERN_HANDLERS are called (the `_execute_mapping` or equivalent method). Add `column_aliases=self._build_column_aliases(merged_df)` to the kwargs dict that gets passed to handlers.

       c. Also pass `cross_domain_dfs` in kwargs if additional DataFrames are available in `raw_dfs` beyond the primary domain dataset. This lets MIN_DATE_PER_SUBJECT access EX data when executing DM.

       d. In the `_resolve_source_variable` method (or wherever source_variable is checked against df.columns before calling the handler), add a resolution step: if `mapping.source_variable` is not in df.columns, check the alias map. If found, update the source_variable reference (or pass the resolved name). Do NOT mutate the mapping object -- pass resolution through kwargs or resolve inline.

    2. Write test `tests/unit/execution/test_executor_resolution.py`:
       - test_build_column_aliases: DataFrame with "Subject" and "SiteNumber" columns -> aliases include SSUBJID->Subject, SSITENUM->SiteNumber
       - test_aliases_only_for_present_columns: DataFrame without "SiteNumber" -> SSITENUM not in aliases
       - test_executor_resolves_ecrf_names: Create a minimal DomainMappingSpec with source_variable="SSUBJID" for a DIRECT mapping. Execute against a DataFrame with "Subject" column. Verify the value is carried through (not KeyError).
       - test_executor_passes_cross_domain_dfs: When raw_dfs contains extra datasets beyond the primary, verify they are accessible via kwargs in pattern handlers.
  </action>
  <verify>pytest tests/unit/execution/test_executor_resolution.py -xvs && pytest tests/ -x -q</verify>
  <done>Executor resolves eCRF column names to actual SAS column names. SSUBJID resolves to Subject, SSITENUM resolves to SiteNumber. Cross-domain DataFrames passed to pattern handlers. All existing tests pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/unit/mapping/test_prompts_vocabulary.py tests/unit/execution/test_executor_resolution.py -xvs` -- new tests pass
- `pytest tests/ -x -q` -- all 1567+ existing tests pass
- `ruff check src/astraea/mapping/prompts.py src/astraea/execution/executor.py` -- no lint errors
- `mypy src/astraea/mapping/prompts.py src/astraea/execution/executor.py` -- no type errors
</verification>

<success_criteria>
- MAPPING_SYSTEM_PROMPT contains all 10 derivation rule keywords
- Prompt instructs LLM to use actual SAS column names
- Executor resolves SSUBJID -> Subject, SSITENUM -> SiteNumber
- Column aliases and cross_domain_dfs passed through kwargs to pattern handlers
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-execution-contract/11-03-SUMMARY.md`
</output>
