---
phase: 11-execution-contract
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/validation/report.py
  - src/astraea/transforms/dates.py
  - src/astraea/validation/autofix.py
  - tests/unit/validation/test_report_wildcard.py
  - tests/unit/transforms/test_date_edge_cases.py
  - tests/unit/validation/test_autofix_usubjid.py
autonomous: true

must_haves:
  truths:
    - "known_false_positives.json entries with '*' wildcard domain/variable match all domains/variables"
    - "format_partial_iso8601 with hour but no minute truncates time component entirely"
    - "DDMonYYYY format (e.g. '30MAR2022') parses to ISO 8601 date"
    - "USUBJID auto-fix classification is NEEDS_HUMAN, not AUTO_FIXABLE"
  artifacts:
    - path: "src/astraea/validation/report.py"
      provides: "Wildcard matching in flag_known_false_positives"
      contains: 'entry_domain != "\\*"'
    - path: "src/astraea/transforms/dates.py"
      provides: "Partial ISO 8601 hour-without-minute fix + DDMonYYYY pattern"
      contains: "_PATTERN_DDMONYYYY"
    - path: "src/astraea/validation/autofix.py"
      provides: "USUBJID classified as NEEDS_HUMAN"
  key_links:
    - from: "src/astraea/validation/report.py"
      to: "src/astraea/validation/known_false_positives.json"
      via: "wildcard matching in flag_known_false_positives"
      pattern: 'entry_domain != "\\*"'
---

<objective>
Fix four targeted bugs identified in the Master Audit: CRIT-01 (wildcard matching in known_false_positives), HIGH-17 (ISO 8601 hour-without-minute), MED-18 (DDMonYYYY date format), and HIGH-10 (USUBJID auto-fix classification).

Purpose: These are isolated, well-understood bugs with exact root causes and fixes. Fixing them independently clears the smaller audit items before the larger derivation rule work.
Output: Four bug fixes with regression tests, all existing 1567+ tests still passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/MASTER_AUDIT.md
@.planning/phases/11-execution-contract/11-RESEARCH.md
@src/astraea/validation/report.py
@src/astraea/transforms/dates.py
@src/astraea/validation/autofix.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix wildcard matching + USUBJID auto-fix classification</name>
  <files>
    src/astraea/validation/report.py
    src/astraea/validation/autofix.py
    tests/unit/validation/test_report_wildcard.py
    tests/unit/validation/test_autofix_usubjid.py
  </files>
  <action>
    1. In `src/astraea/validation/report.py`, method `flag_known_false_positives()`, lines 112-114:
       Change:
         `if entry_domain is not None and result.domain != entry_domain:`
       To:
         `if entry_domain is not None and entry_domain != "*" and result.domain != entry_domain:`
       And change:
         `if entry_variable is not None and result.variable != entry_variable:`
       To:
         `if entry_variable is not None and entry_variable != "*" and result.variable != entry_variable:`

    2. In `src/astraea/validation/autofix.py`:
       - Remove "USUBJID" from `_AUTO_FIXABLE_MISSING_VARS` (line 67). Change to: `_AUTO_FIXABLE_MISSING_VARS = {"STUDYID", "DOMAIN"}`
       - In `apply_fixes()`, remove the USUBJID branch (lines 318-321) that does `continue`. The NEEDS_HUMAN classification will cause it to skip via the `classification != AUTO_FIXABLE` check at line 295.

    3. Write test `tests/unit/validation/test_report_wildcard.py`:
       - Test that a whitelist entry with domain="*" matches results with domain="DM", "AE", etc.
       - Test that a whitelist entry with variable="*" matches any variable
       - Test that domain=null still means "match all" (existing behavior preserved)

    4. Write test `tests/unit/validation/test_autofix_usubjid.py`:
       - Test that `classify_issue()` for ASTR-P001 with variable=USUBJID returns NEEDS_HUMAN
       - Test that STUDYID and DOMAIN still return AUTO_FIXABLE
  </action>
  <verify>pytest tests/unit/validation/test_report_wildcard.py tests/unit/validation/test_autofix_usubjid.py -xvs</verify>
  <done>Wildcard "*" entries in known_false_positives.json now match all domains/variables. USUBJID auto-fix correctly classified as NEEDS_HUMAN.</done>
</task>

<task type="auto">
  <name>Task 2: Fix ISO 8601 partial date + DDMonYYYY format</name>
  <files>
    src/astraea/transforms/dates.py
    tests/unit/transforms/test_date_edge_cases.py
  </files>
  <action>
    1. In `src/astraea/transforms/dates.py`, function `format_partial_iso8601()`:
       Around line 379-381, change the hour handling:
       BEFORE:
         if hour is None:
             return result
         result += f"T{hour:02d}"
         if minute is None:
             return result
       AFTER:
         if hour is None or minute is None:
             return result
         result += f"T{hour:02d}:{minute:02d}"

       Then the minute block (lines 384-385) can be removed since it's now handled above. The second handling remains:
         if second is None:
             return result
         result += f":{second:02d}"

    2. Add DDMonYYYY regex pattern in `dates.py`:
       Add `_PATTERN_DDMONYYYY = re.compile(r"^\s*(\d{1,2})(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(\d{4})\s*$", re.IGNORECASE)`

       In `parse_string_date_to_iso()`, add a match attempt for `_PATTERN_DDMONYYYY` AFTER the existing `_PATTERN_DD_MON_YYYY` match attempt. If matched, extract day/month/year, validate with `_validate_date_components()`, and return `f"{year:04d}-{month:02d}-{day:02d}"`.

       Also add DDMonYYYY detection in `detect_date_format()` so the profiler recognizes this format. Add a check after the DD Mon YYYY check: `elif _PATTERN_DDMONYYYY.match(s): format_counts["DDMonYYYY"] = ...`

    3. Write test `tests/unit/transforms/test_date_edge_cases.py`:
       - `test_partial_iso8601_hour_without_minute`: `format_partial_iso8601(2023, 3, 15, 10, None, None)` returns `"2023-03-15"` (NOT "2023-03-15T10")
       - `test_partial_iso8601_hour_with_minute`: `format_partial_iso8601(2023, 3, 15, 10, 30, None)` returns `"2023-03-15T10:30"` (unchanged behavior)
       - `test_ddmonyyyy_no_spaces`: `parse_string_date_to_iso("30MAR2022")` returns `"2022-03-30"`
       - `test_ddmonyyyy_lowercase`: `parse_string_date_to_iso("15jan2023")` returns `"2023-01-15"`
       - `test_ddmonyyyy_single_digit_day`: `parse_string_date_to_iso("5FEB2021")` returns `"2021-02-05"`
       - `test_detect_ddmonyyyy_format`: `detect_date_format(["30MAR2022", "15JAN2023"])` returns `"DDMonYYYY"`
  </action>
  <verify>pytest tests/unit/transforms/test_date_edge_cases.py -xvs && pytest tests/ -x -q</verify>
  <done>format_partial_iso8601 with hour-without-minute returns date-only (no invalid "T10"). DDMonYYYY dates parse correctly. All 1567+ existing tests still pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/ -x -q` -- all 1567+ tests pass
- `ruff check src/astraea/validation/report.py src/astraea/transforms/dates.py src/astraea/validation/autofix.py` -- no lint errors
- `mypy src/astraea/validation/report.py src/astraea/transforms/dates.py src/astraea/validation/autofix.py` -- no type errors
</verification>

<success_criteria>
- CRIT-01: Wildcard "*" matching works in known_false_positives
- HIGH-17: format_partial_iso8601(2023, 3, 15, 10, None, None) returns "2023-03-15"
- MED-18: parse_string_date_to_iso("30MAR2022") returns "2022-03-30"
- HIGH-10: USUBJID classified as NEEDS_HUMAN in autofix
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-execution-contract/11-01-SUMMARY.md`
</output>
