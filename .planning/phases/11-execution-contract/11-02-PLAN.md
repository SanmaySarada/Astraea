---
phase: 11-execution-contract
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/execution/pattern_handlers.py
  - tests/unit/execution/test_derivation_parser.py
  - tests/unit/execution/test_derivation_handlers.py
autonomous: true

must_haves:
  truths:
    - "parse_derivation_rule extracts keyword and arguments from KEYWORD(arg1, arg2) format"
    - "Dataset prefixes (dm.COL) are stripped during argument parsing"
    - "All 10 derivation rule keywords dispatch to handler functions"
    - "CONCAT handler concatenates column values and literal strings"
    - "GENERATE_USUBJID handler delegates to generate_usubjid_column"
    - "ISO8601_DATE handler converts SAS numeric dates"
    - "ISO8601_PARTIAL_DATE handler builds partial ISO dates from year/month/day components"
    - "RACE_CHECKBOX handler derives RACE from 0/1 checkbox columns"
    - "MIN_DATE_PER_SUBJECT and MAX_DATE_PER_SUBJECT aggregate dates across rows"
  artifacts:
    - path: "src/astraea/execution/pattern_handlers.py"
      provides: "Derivation rule parser and dispatch table with 10+ rule handlers"
      contains: "_DERIVATION_DISPATCH"
  key_links:
    - from: "src/astraea/execution/pattern_handlers.py"
      to: "src/astraea/transforms/usubjid.py"
      via: "GENERATE_USUBJID handler calls generate_usubjid_column"
      pattern: "generate_usubjid_column"
    - from: "src/astraea/execution/pattern_handlers.py"
      to: "src/astraea/transforms/dates.py"
      via: "ISO8601_DATE handler calls sas_date_to_iso"
      pattern: "sas_date_to_iso"
---

<objective>
Implement the formal derivation rule vocabulary parser and all handler functions in pattern_handlers.py. This is the core fix for CRIT-02 and CRIT-03 -- the gap between what the LLM proposes and what the executor can execute.

Purpose: Without this, the execution pipeline produces all-NULL columns for any derived variable. This is the single most critical fix in Phase 11.
Output: A derivation rule parser, 10+ handler functions, column name resolution helper, and comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/MASTER_AUDIT.md
@.planning/phases/11-execution-contract/11-RESEARCH.md
@src/astraea/execution/pattern_handlers.py
@src/astraea/execution/executor.py
@src/astraea/transforms/usubjid.py
@src/astraea/transforms/dates.py
@src/astraea/transforms/recoding.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Derivation rule parser and column resolution helper</name>
  <files>
    src/astraea/execution/pattern_handlers.py
    tests/unit/execution/test_derivation_parser.py
  </files>
  <action>
    Add to `pattern_handlers.py`:

    1. **Rule parser function** `parse_derivation_rule(rule: str) -> tuple[str, list[str]]`:
       - Uses regex `r'^(\w+)\s*\((.*)\)$'` (re.DOTALL) to extract keyword and args
       - Keyword is uppercased
       - Arguments split on commas, stripped of quotes and whitespace
       - Dataset prefixes stripped: if arg contains '.' and is not a numeric literal (like '3.14'), split on '.' and take the last part
       - If no parens match, return (rule.strip().upper(), [])
       - Import `re` at top of file

    2. **Column resolution helper** `_resolve_column(df: pd.DataFrame, name: str, kwargs: dict) -> str | None`:
       - Strip dataset prefix (dm.COL -> COL)
       - Exact match against df.columns
       - Check `kwargs.get("column_aliases", {})` dict
       - Check hardcoded EDC aliases: {"SSUBJID": "Subject", "SSITENUM": "SiteNumber", "SSITE": "Site", "SSITEGROUP": "SiteGroup"}
       - Case-insensitive fallback: try name.lower() against df.columns lowercased
       - Return None if no match found

    3. **Race name extractor** `_extract_race_from_col(col_name: str, df: pd.DataFrame) -> str | None`:
       - Check column label from df.attrs.get("column_labels", {}).get(col_name)
       - Fallback: parse from column name patterns (RACEAME -> "American Indian or Alaska Native", RACEASI -> "Asian", RACEBLA -> "Black or African American", RACENAT -> "Native Hawaiian or Other Pacific Islander", RACEWHI -> "White", RACEOTH -> "Other", RACENR -> "Not Reported")
       - Return None if unrecognized

    Write test file `tests/unit/execution/test_derivation_parser.py`:
    - test_parse_simple: `parse_derivation_rule("CONCAT('a', '-', 'b')")` returns `("CONCAT", ["a", "-", "b"])`
    - test_parse_with_dataset_prefix: `parse_derivation_rule("CONCAT(dm.AGE, '-', irt.SSITENUM)")` returns `("CONCAT", ["AGE", "-", "SSITENUM"])`
    - test_parse_bare_keyword: `parse_derivation_rule("GENERATE_USUBJID")` returns `("GENERATE_USUBJID", [])`
    - test_parse_single_arg: `parse_derivation_rule("ISO8601_DATE(AESTDAT_INT)")` returns `("ISO8601_DATE", ["AESTDAT_INT"])`
    - test_resolve_exact_match: `_resolve_column(df_with_Subject, "Subject", {})` returns `"Subject"`
    - test_resolve_edc_alias: `_resolve_column(df_with_Subject, "SSUBJID", {})` returns `"Subject"`
    - test_resolve_custom_alias: `_resolve_column(df, "MYCOL", {"column_aliases": {"MYCOL": "ActualCol"}})` returns `"ActualCol"`
    - test_resolve_not_found: `_resolve_column(df, "NONEXISTENT", {})` returns `None`
    - test_extract_race_raceame: returns "American Indian or Alaska Native"
    - test_extract_race_racewhi: returns "White"
  </action>
  <verify>pytest tests/unit/execution/test_derivation_parser.py -xvs</verify>
  <done>parse_derivation_rule correctly parses KEYWORD(args) format. _resolve_column resolves eCRF names to SAS column names. Race name extraction works for all standard race checkbox columns.</done>
</task>

<task type="auto">
  <name>Task 2: Implement all derivation rule handlers and dispatch</name>
  <files>
    src/astraea/execution/pattern_handlers.py
    tests/unit/execution/test_derivation_handlers.py
  </files>
  <action>
    Add handler functions and dispatch table to `pattern_handlers.py`:

    1. **`_DERIVATION_DISPATCH` dict** mapping keyword -> handler function:
       ```
       GENERATE_USUBJID, CONCAT, ISO8601_DATE, ISO8601_DATETIME,
       ISO8601_PARTIAL_DATE, PARSE_STRING_DATE, MIN_DATE_PER_SUBJECT,
       MAX_DATE_PER_SUBJECT, RACE_CHECKBOX, RACE_FROM_CHECKBOXES (alias),
       NUMERIC_TO_YN, LAST_DISPOSITION_DATE (alias for MAX_DATE)
       ```

    2. **Handler functions** (all take `df, args, mapping, **kwargs` and return `pd.Series`):

       - `_handle_generate_usubjid`: Call `generate_usubjid_column()` using kwargs study_id, site_col (resolved via _resolve_column), subject_col (resolved via _resolve_column). If args provided, use args[0] as study_id literal.

       - `_handle_concat`: For each arg, try _resolve_column to get a DataFrame column; if not found, treat as literal string. Concatenate all parts element-wise. Handle NaN by converting to empty string before concat.

       - `_handle_iso8601_date`: Resolve single arg to column. Apply `sas_date_to_iso` element-wise via .map(). Import from `astraea.transforms.dates`.

       - `_handle_iso8601_datetime`: Same but use `sas_datetime_to_iso`.

       - `_handle_iso8601_partial_date`: Args are 1-3 column names (year, month, day). Resolve each. Call `format_partial_iso8601()` row-wise with available components. If only year column provided, return year as 4-digit string.

       - `_handle_parse_string_date`: Resolve single arg. Apply `parse_string_date_to_iso` element-wise.

       - `_handle_min_date_per_subject`: Resolve date column arg. Look for USUBJID in df (or resolve via alias). Group by USUBJID, find min date, map back. Uses `sas_date_to_iso` if values are numeric. If source column is from a different dataset, check `kwargs.get("cross_domain_dfs", {})`.

       - `_handle_max_date_per_subject`: Same as min but max.

       - `_handle_race_checkbox`: As documented in 11-RESEARCH.md. Map checkbox column names through CT_RACE_MAP. Return "MULTIPLE" if >1 checked, single race name if exactly 1, None if 0.

       - `_handle_numeric_to_yn`: Resolve arg. Apply `numeric_to_yn` from `astraea.transforms.recoding`.

    3. **Update `handle_derivation()`**: Replace the current body with:
       - Call `parse_derivation_rule(rule)` to get keyword and args
       - Look up keyword in `_DERIVATION_DISPATCH`
       - If found, call the handler with (df, args, mapping, **kwargs)
       - If not found, fall back to existing behavior (check get_transform, then return None with warning)
       - Keep the existing USUBJID special-case as a fallback for bare "USUBJID" rules

    4. **Update `handle_reformat()`**: Add derivation rule parsing:
       - If `mapping.derivation_rule` matches a known keyword via parse_derivation_rule, dispatch to that handler
       - Only fall through to `get_transform()` if no keyword match

    5. **Update `handle_combine()`**: Dispatch through parse_derivation_rule + _DERIVATION_DISPATCH, falling back to USUBJID special case.

    Write test file `tests/unit/execution/test_derivation_handlers.py`:
    - test_handle_concat_columns: df with col_a="X", col_b="Y", CONCAT(col_a, '-', col_b) -> "X-Y"
    - test_handle_concat_literal_and_col: CONCAT('PREFIX', '-', col_a) -> "PREFIX-X"
    - test_handle_iso8601_date: numeric SAS date 22738 -> "2022-03-30"
    - test_handle_iso8601_partial_date_year_only: year=1960 -> "1960"
    - test_handle_iso8601_partial_date_year_month: year=2023, month=3 -> "2023-03"
    - test_handle_parse_string_date: "30 Mar 2022" -> "2022-03-30"
    - test_handle_min_date_per_subject: two rows same USUBJID, different dates -> both get min
    - test_handle_max_date_per_subject: same -> both get max
    - test_handle_race_checkbox_single: RACEAME=0, RACEWHI=1 -> "WHITE"
    - test_handle_race_checkbox_multiple: RACEAME=1, RACEWHI=1 -> "MULTIPLE"
    - test_handle_race_checkbox_none: all 0 -> None
    - test_handle_numeric_to_yn: 1 -> "Y", 0 -> "N"
    - test_handle_derivation_dispatches_concat: handle_derivation with derivation_rule="CONCAT(...)" uses CONCAT handler
    - test_handle_reformat_dispatches_iso8601: handle_reformat with derivation_rule="ISO8601_DATE(COL)" dispatches correctly
    - test_unrecognized_rule_returns_none: unknown keyword returns None series with warning
  </action>
  <verify>pytest tests/unit/execution/test_derivation_handlers.py -xvs && pytest tests/ -x -q</verify>
  <done>All 10+ derivation rule handlers implemented and tested. handle_derivation and handle_reformat dispatch through the parser. Unrecognized rules still return None with warning. All existing tests pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/unit/execution/ -xvs` -- all new handler tests pass
- `pytest tests/ -x -q` -- all 1567+ existing tests pass
- `ruff check src/astraea/execution/pattern_handlers.py` -- no lint errors
- `mypy src/astraea/execution/pattern_handlers.py` -- no type errors
</verification>

<success_criteria>
- parse_derivation_rule("CONCAT('a', '-', dm.COL)") returns ("CONCAT", ["a", "-", "COL"])
- handle_derivation with derivation_rule="GENERATE_USUBJID" produces non-NULL USUBJID
- handle_derivation with derivation_rule="CONCAT(...)" concatenates values correctly
- handle_derivation with derivation_rule="ISO8601_DATE(COL)" converts SAS dates
- handle_derivation with derivation_rule="RACE_CHECKBOX(RACEAME, RACEWHI)" derives RACE
- All 10 rule keywords dispatch to their handlers
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-execution-contract/11-02-SUMMARY.md`
</output>
