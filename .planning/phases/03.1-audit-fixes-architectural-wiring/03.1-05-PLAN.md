---
phase: 03.1-audit-fixes-architectural-wiring
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/profiling/profiler.py
  - src/astraea/io/xpt_writer.py
  - src/astraea/transforms/dates.py
  - src/astraea/mapping/engine.py
  - src/astraea/mapping/prompts.py
  - src/astraea/mapping/transform_registry.py
  - tests/unit/profiling/test_profiler.py
  - tests/unit/io/test_xpt_writer.py
  - tests/unit/transforms/test_dates.py
  - tests/unit/mapping/test_transform_registry.py
autonomous: true

must_haves:
  truths:
    - "Profiler detect_date_format correctly distinguishes DD/MM/YYYY from MM/DD/YYYY"
    - "Profiler detects string dates in _RAW columns even without DAT in the name"
    - "XPT writer validates dataset label length (max 40 chars)"
    - "XPT writer warns about unlabeled columns"
    - "dates.py docstring examples match actual function output"
    - "transforms/ has at least one production import path (transform_registry.py)"
    - "MappingEngine wraps LLM call errors with domain context"
    - "SUPPQUAL prompt includes QNAM rules, QORIG values, and EDC exclusion guidance"
  artifacts:
    - path: "src/astraea/profiling/profiler.py"
      provides: "Fixed date format disambiguation and broadened _RAW column detection"
      contains: "SLASH_DATE"
    - path: "src/astraea/io/xpt_writer.py"
      provides: "Dataset label validation and unlabeled column warning"
      contains: "table_label"
    - path: "src/astraea/mapping/prompts.py"
      provides: "Enhanced SUPPQUAL guidance with QNAM rules, QORIG values, EDC exclusion"
      contains: "QNAM"
    - path: "src/astraea/mapping/transform_registry.py"
      provides: "Registry of available deterministic transforms"
      contains: "AVAILABLE_TRANSFORMS"
  key_links:
    - from: "src/astraea/mapping/transform_registry.py"
      to: "src/astraea/transforms/dates.py"
      via: "import"
      pattern: "from astraea.transforms.dates import"
    - from: "src/astraea/mapping/transform_registry.py"
      to: "src/astraea/transforms/usubjid.py"
      via: "import"
      pattern: "from astraea.transforms.usubjid import"
---

<objective>
Fix profiler date disambiguation and broaden date column detection, fix XPT writer gaps, fix docstring errors, add engine error wrapping, enhance SUPPQUAL prompt guidance, and wire transforms/ into production code via a transform registry module.

Purpose: The profiler can never return "MM/DD/YYYY" (dead code bug) and misses date columns without "DAT" in the name. The XPT writer silently accepts datasets without labels, risking P21 failures. The SUPPQUAL prompt gives the LLM no rules about QNAM constraints, valid QORIG values, or EDC variable exclusion, leading to invalid SUPPQUAL proposals. transforms/ has zero production imports despite being core infrastructure. These fixes complete the foundation for Phase 4 execution.

Output: Fixed profiler, enhanced XPT writer, corrected docstrings, enhanced SUPPQUAL prompts, transform registry module, all with tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/PHASE3_AUDIT.md (sections H-10, H-11, H-12, H-13, M-01, M-02, M-03, A-01)
@.planning/phases/03.1-audit-fixes-architectural-wiring/03.1-RESEARCH.md (sections "Fix 4", "Fix 5", "Fix 6")
@src/astraea/profiling/profiler.py
@src/astraea/io/xpt_writer.py
@src/astraea/transforms/dates.py
@src/astraea/transforms/usubjid.py
@src/astraea/mapping/engine.py
@src/astraea/mapping/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix profiler date disambiguation, broaden date column detection, and fix XPT writer gaps</name>
  <files>
    src/astraea/profiling/profiler.py
    src/astraea/io/xpt_writer.py
  </files>
  <action>
**1. Fix profiler detect_date_format (profiler.py lines 75-104):**

Replace the _DATE_PATTERNS list and detect_date_format function. The current code has both "DD/MM/YYYY" and "MM/DD/YYYY" with IDENTICAL regex, so MM/DD/YYYY can never be returned (it's dead code).

Replace lines 75-82 with:
```python
_DATE_PATTERNS: list[tuple[str, re.Pattern[str]]] = [
    ("DD Mon YYYY", re.compile(r"^\d{1,2}\s+[A-Za-z]{3}\s+\d{4}$")),
    ("YYYY-MM-DD", re.compile(r"^\d{4}-\d{1,2}-\d{1,2}$")),
    ("DD-Mon-YYYY", re.compile(r"^\d{1,2}-[A-Za-z]{3}-\d{4}$")),
    ("YYYY-MM-DDTHH:MM:SS", re.compile(r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}")),
    ("SLASH_DATE", re.compile(r"^\d{1,2}/\d{1,2}/\d{4}$")),
]
```

In detect_date_format(), after the existing loop that matches patterns, add disambiguation logic for SLASH_DATE:
```python
if format_name == "SLASH_DATE":
    # Disambiguate DD/MM/YYYY vs MM/DD/YYYY by checking if any first-part values exceed 12
    for s in samples:
        s = s.strip()
        m = re.match(r"^(\d{1,2})/(\d{1,2})/(\d{4})$", s)
        if m:
            first, second = int(m.group(1)), int(m.group(2))
            if first > 12:
                return "DD/MM/YYYY"
            if second > 12:
                return "MM/DD/YYYY"
    # All ambiguous -- default to DD/MM/YYYY per project convention (D-0104-01)
    return "DD/MM/YYYY"
```

**2. Broaden _RAW column date detection (profiler.py, M-02):**

The current `_is_potential_string_date_column()` requires BOTH `_RAW` AND `DAT` in the column name. This misses columns like `VISIT_RAW`, `ENRL_RAW`, or other `_RAW` columns that contain dates but do not have "DAT" in their name.

Replace `_is_potential_string_date_column`:
```python
def _is_potential_string_date_column(name: str) -> bool:
    """Check if column name suggests it might contain string dates.

    Looks for _RAW columns (case insensitive). All _RAW columns are
    candidates for string date detection because EDC systems store
    human-entered dates in _RAW variants. The detect_date_format
    function will return None if the values don't match any date pattern,
    so false positives are harmless.
    """
    return "_RAW" in name.upper()
```

This broadens detection to all `_RAW` columns. The downstream `detect_date_format()` call already returns None if the sample values don't match any date pattern, so broadening the filter is safe -- false positive column names just get checked and rejected.

**3. Add XPT writer dataset label validation (xpt_writer.py):**

Add `table_label: str | None = None` parameter to both `validate_for_xpt_v5()` and `write_xpt_v5()`.

In validate_for_xpt_v5(), add these checks:
```python
# Table label validation
if table_label is not None and len(table_label) > 40:
    errors.append(
        f"Table label exceeds 40 characters ({len(table_label)} chars): "
        f"'{table_label[:50]}...'"
    )

# Unlabeled column warning
for col in df.columns:
    col_str = str(col)
    if col_str not in column_labels:
        # Case-insensitive fallback
        if col_str.upper() not in {k.upper() for k in column_labels}:
            errors.append(
                f"Column '{col_str}' has no label defined -- "
                f"every SDTM variable must have a label"
            )
```

In write_xpt_v5():
- Add `table_label: str | None = None` parameter
- Pass `table_label` to validate_for_xpt_v5()
- Pass `table_label` to pyreadstat.write_xport() if not None:
```python
write_kwargs = dict(
    table_name=upper_table,
    column_labels=upper_labels,
    file_format_version=5,
)
if table_label is not None:
    write_kwargs["table_label"] = table_label
pyreadstat.write_xport(df_out, str(path), **write_kwargs)
```
  </action>
  <verify>
Run: `python -c "from astraea.profiling.profiler import detect_date_format; print(detect_date_format(['03/15/2022', '12/25/2021']))"` -- should print "MM/DD/YYYY".
Run: `python -c "from astraea.profiling.profiler import detect_date_format; print(detect_date_format(['15/03/2022', '25/12/2021']))"` -- should print "DD/MM/YYYY".
Run: `python -c "from astraea.profiling.profiler import _is_potential_string_date_column; print(_is_potential_string_date_column('VISIT_RAW'))"` -- should print True.
  </verify>
  <done>Profiler correctly disambiguates slash dates and detects dates in all _RAW columns. XPT writer validates dataset labels and warns about unlabeled columns.</done>
</task>

<task type="auto">
  <name>Task 2: Fix docstrings, add error wrapping, enhance SUPPQUAL prompts, create transform registry</name>
  <files>
    src/astraea/transforms/dates.py
    src/astraea/mapping/engine.py
    src/astraea/mapping/prompts.py
    src/astraea/mapping/transform_registry.py
  </files>
  <action>
**1. Fix dates.py docstring examples (lines ~115-116 and ~145-146):**

Line 115: Change `sas_date_to_iso(22739.0)` example.
The actual correct values:
- SAS date 22739 = 1960-01-01 + 22739 days = 2022-04-04
- The docstring claims '2022-03-30' which is wrong
- Fix: Change to `sas_date_to_iso(22734.0)` -> `'2022-03-30'` OR change the expected output to `'2022-04-04'`
- Simplest: Change the example to use a known correct pair. Use: `sas_date_to_iso(0.0)` -> `'1960-01-01'` (already in docstring) and update the first example to: `sas_date_to_iso(22734.0)` -> `'2022-03-30'`

Line 145: Change `sas_datetime_to_iso(1964217600.0)` example.
The actual value: 1960-01-01 + 1964217600 seconds = ?
- 1964217600 / 86400 = 22735.852... days = 1960-01-01 + 22735 days ~ 2022-03-31
- The docstring claims '2022-03-15T00:00:00' which is wrong
- Fix: Change to use a correct pair. Use: `sas_datetime_to_iso(1963526400.0)` -> `'2022-03-23T00:00:00'` or just compute the correct value for 2022-03-30: (22734 * 86400) = 1964937600.0 -> '2022-03-30T00:00:00'
- Safest: Compute correct pairs in a Python REPL first, then use them.

IMPORTANT: Run `python -c "from astraea.transforms.dates import sas_date_to_iso, sas_datetime_to_iso; print(sas_date_to_iso(22739.0)); print(sas_datetime_to_iso(1964217600.0))"` first to see actual outputs, then update docstrings to match.

**2. Add domain-specific error wrapping to engine.py (around line 137):**

Wrap the LLM call in a try/except that adds domain context:
```python
try:
    proposal = self._llm.parse(
        model=model,
        messages=[{"role": "user", "content": full_prompt}],
        system=MAPPING_SYSTEM_PROMPT,
        output_format=DomainMappingProposal,
        temperature=temperature,
        max_tokens=max_tokens,
    )
except Exception as e:
    msg = f"LLM mapping call failed for domain '{domain}': {e}"
    logger.error(msg)
    raise RuntimeError(msg) from e
```

**3. Enhance SUPPQUAL prompt guidance (prompts.py, H-10):**

In `MAPPING_SYSTEM_PROMPT`, replace the existing minimal SUPPQUAL guidance (the line about "Identify unmapped source variables and classify them as suppqual_candidates if they contain non-standard clinical data") with comprehensive SUPPQUAL rules. Add a new section after the Instructions section:

```python
## SUPPQUAL Candidate Rules

When identifying suppqual_candidates, follow these rules:

1. **QNAM constraints:** Each SUPPQUAL variable name (QNAM) must be:
   - Maximum 8 characters
   - Alphanumeric characters only (valid SAS variable name)
   - Must NOT duplicate any variable name in the parent domain
   - Use meaningful abbreviations (e.g., AEACNOTH for "AE Action Taken Other")

2. **QORIG (Origin) values:** Each SUPPQUAL record must specify origin. \
Valid QORIG values are: "CRF", "DERIVED", "ASSIGNED", "PROTOCOL", "COLLECTED".

3. **EDC system variables are NOT SUPPQUAL candidates.** Exclude these \
categories from suppqual_candidates:
   - EDC administrative columns (projectid, instanceId, DataPageId, \
RecordId, StudyEventRepeatKey, etc.)
   - Audit trail columns (Created, Updated, CreatedBy, etc.)
   - System metadata (FormOID, ItemGroupOID, etc.)
   These are infrastructure artifacts, not clinical data.

4. **Only non-standard CLINICAL data belongs in SUPPQUAL.** A variable \
is a suppqual_candidate if it: (a) contains clinically meaningful data, \
(b) does not map to any standard variable in the parent domain, and \
(c) is not an EDC system variable.
```

Also update `MAPPING_USER_INSTRUCTIONS` to reinforce the SUPPQUAL rules. Change the existing lines:
```
List any source variables that do not map to a standard {domain} variable \
in unmapped_source_variables.

Identify non-standard clinical variables that may belong in \
SUPP{domain} as suppqual_candidates.
```
To:
```
List any source variables that do not map to a standard {domain} variable \
in unmapped_source_variables. Do NOT include EDC system/administrative \
columns in this list.

Identify non-standard CLINICAL variables that may belong in \
SUPP{domain} as suppqual_candidates. For each candidate, ensure the \
proposed QNAM is <=8 chars, alphanumeric, and does not duplicate any \
standard {domain} variable name. Do NOT include EDC system variables \
(projectid, instanceId, DataPageId, RecordId, etc.) as SUPPQUAL candidates.
```

**4. Create transform registry module (NEW file):**

Create `src/astraea/mapping/transform_registry.py`:
```python
"""Registry of available deterministic transforms for mapping specs.

Makes transform function signatures discoverable by the mapping engine
so that derivation_rule references can be validated against actual
available transforms. This module is the production code import path
for the transforms/ package.
"""

from __future__ import annotations

from typing import Callable

from astraea.transforms.dates import (
    format_partial_iso8601,
    parse_string_date_to_iso,
    sas_date_to_iso,
    sas_datetime_to_iso,
)
from astraea.transforms.usubjid import (
    generate_usubjid,
    generate_usubjid_column,
)

AVAILABLE_TRANSFORMS: dict[str, Callable] = {
    "sas_date_to_iso": sas_date_to_iso,
    "sas_datetime_to_iso": sas_datetime_to_iso,
    "parse_string_date_to_iso": parse_string_date_to_iso,
    "format_partial_iso8601": format_partial_iso8601,
    "generate_usubjid": generate_usubjid,
    "generate_usubjid_column": generate_usubjid_column,
}


def get_transform(name: str) -> Callable | None:
    """Look up a transform function by name.

    Args:
        name: Transform function name (e.g., "sas_date_to_iso").

    Returns:
        The callable transform function, or None if not found.
    """
    return AVAILABLE_TRANSFORMS.get(name)


def list_transforms() -> list[str]:
    """Return names of all registered transforms.

    Returns:
        Sorted list of transform function names.
    """
    return sorted(AVAILABLE_TRANSFORMS.keys())
```

This creates the production import path from mapping/ to transforms/, resolving architectural gap A-01.
  </action>
  <verify>
Run: `python -c "from astraea.mapping.transform_registry import list_transforms; print(list_transforms())"` -- should print 6 transform names.
Run: `python -c "from astraea.mapping.transform_registry import get_transform; fn = get_transform('sas_date_to_iso'); print(fn(0.0))"` -- should print '1960-01-01'.
Run: `ruff check src/astraea/transforms/dates.py src/astraea/mapping/engine.py src/astraea/mapping/prompts.py src/astraea/mapping/transform_registry.py` -- clean.
Manually verify prompts.py contains "QNAM", "QORIG", "EDC system variables" text.
  </verify>
  <done>Docstrings corrected, LLM errors wrapped with domain context, SUPPQUAL prompt enhanced with QNAM/QORIG/EDC rules, transform registry created bridging transforms/ to production code</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for all fixes</name>
  <files>
    tests/unit/profiling/test_profiler.py
    tests/unit/io/test_xpt_writer.py
    tests/unit/transforms/test_dates.py
    tests/unit/mapping/test_transform_registry.py
  </files>
  <action>
**1. Profiler date disambiguation tests (test_profiler.py):**
- Test detect_date_format(["15/03/2022", "25/12/2021"]) == "DD/MM/YYYY" (first > 12)
- Test detect_date_format(["03/15/2022", "12/25/2021"]) == "MM/DD/YYYY" (second > 12)
- Test detect_date_format(["03/04/2022", "01/02/2021"]) == "DD/MM/YYYY" (ambiguous, default)
- Test detect_date_format(["30 Mar 2022"]) == "DD Mon YYYY" (non-slash patterns still work)

**2. Profiler broadened _RAW detection tests (test_profiler.py, M-02):**
- Test _is_potential_string_date_column("VISIT_RAW") == True (no DAT, but has _RAW)
- Test _is_potential_string_date_column("ENRL_RAW") == True
- Test _is_potential_string_date_column("BRTHDAT_RAW") == True (still works with DAT)
- Test _is_potential_string_date_column("AGE") == False (no _RAW)
- Test _is_potential_string_date_column("RAWDATA") == False (RAW not preceded by underscore -- wait, "RAWDATA" has "RAW" but not "_RAW". Verify the function uses "_RAW" not just "RAW".)

**3. XPT writer tests (test_xpt_writer.py):**
- Test validate_for_xpt_v5 with table_label > 40 chars returns error
- Test validate_for_xpt_v5 with table_label <= 40 chars returns no error for that check
- Test validate_for_xpt_v5 with unlabeled column returns error mentioning the column name
- Test validate_for_xpt_v5 with all columns labeled returns no unlabeled-column error
- Test that table_label=None (backward compat) still works fine

**4. Docstring test (test_dates.py):**
- Run doctest on dates.py OR add explicit test that the example values in docstrings match actual output. Check `sas_date_to_iso()` and `sas_datetime_to_iso()` examples produce the documented output.

**5. Transform registry tests (NEW file: test_transform_registry.py):**
- Test list_transforms() returns 6 items
- Test get_transform("sas_date_to_iso") is not None and is callable
- Test get_transform("nonexistent") returns None
- Test that each registered transform is actually callable (parametrized)
- Test get_transform("sas_date_to_iso")(0.0) == "1960-01-01"

**6. Run full test suite:** `pytest -x -q`
  </action>
  <verify>`pytest tests/unit/profiling/test_profiler.py tests/unit/io/test_xpt_writer.py tests/unit/transforms/test_dates.py tests/unit/mapping/test_transform_registry.py -v` -- all pass. `pytest -x -q` -- full suite passes.</verify>
  <done>All fixes verified by tests: date disambiguation, broadened _RAW detection, XPT label validation, docstring accuracy, transform registry, full suite passes</done>
</task>

</tasks>

<verification>
- `pytest -x -q` passes
- `ruff check src/ tests/` passes
- `python -c "from astraea.mapping.transform_registry import list_transforms; print(len(list_transforms()))"` prints 6
- `grep -c "QNAM" src/astraea/mapping/prompts.py` returns > 0
</verification>

<success_criteria>
- Profiler correctly returns "MM/DD/YYYY" when appropriate (no more dead code)
- Profiler detects string dates in all _RAW columns, not just *DAT*_RAW
- XPT writer catches oversized dataset labels and unlabeled columns
- dates.py docstring examples match actual outputs
- Engine wraps LLM errors with domain context
- SUPPQUAL prompt includes QNAM <=8 char rule, valid QORIG values, EDC exclusion guidance
- transforms/ has production import path via transform_registry.py
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-audit-fixes-architectural-wiring/03.1-05-SUMMARY.md`
</output>
