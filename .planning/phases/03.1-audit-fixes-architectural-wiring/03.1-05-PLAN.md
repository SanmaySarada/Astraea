---
phase: 03.1-audit-fixes-architectural-wiring
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/profiling/profiler.py
  - src/astraea/io/xpt_writer.py
  - src/astraea/transforms/dates.py
  - src/astraea/mapping/engine.py
  - src/astraea/mapping/transform_registry.py
  - tests/unit/profiling/test_profiler.py
  - tests/unit/io/test_xpt_writer.py
  - tests/unit/transforms/test_dates.py
  - tests/unit/mapping/test_transform_registry.py
autonomous: true

must_haves:
  truths:
    - "Profiler detect_date_format correctly distinguishes DD/MM/YYYY from MM/DD/YYYY"
    - "XPT writer validates dataset label length (max 40 chars)"
    - "XPT writer warns about unlabeled columns"
    - "dates.py docstring examples match actual function output"
    - "transforms/ has at least one production import path (transform_registry.py)"
    - "MappingEngine wraps LLM call errors with domain context"
  artifacts:
    - path: "src/astraea/profiling/profiler.py"
      provides: "Fixed date format disambiguation"
      contains: "SLASH_DATE"
    - path: "src/astraea/io/xpt_writer.py"
      provides: "Dataset label validation and unlabeled column warning"
      contains: "table_label"
    - path: "src/astraea/mapping/transform_registry.py"
      provides: "Registry of available deterministic transforms"
      contains: "AVAILABLE_TRANSFORMS"
  key_links:
    - from: "src/astraea/mapping/transform_registry.py"
      to: "src/astraea/transforms/dates.py"
      via: "import"
      pattern: "from astraea.transforms.dates import"
    - from: "src/astraea/mapping/transform_registry.py"
      to: "src/astraea/transforms/usubjid.py"
      via: "import"
      pattern: "from astraea.transforms.usubjid import"
---

<objective>
Fix profiler date disambiguation, XPT writer gaps, docstring errors, engine error wrapping, and wire transforms/ into production code via a transform registry module.

Purpose: The profiler can never return "MM/DD/YYYY" (dead code bug). The XPT writer silently accepts datasets without labels, risking P21 failures. transforms/ has zero production imports despite being core infrastructure. These fixes complete the foundation for Phase 4 execution.

Output: Fixed profiler, enhanced XPT writer, corrected docstrings, transform registry module, all with tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/PHASE3_AUDIT.md (sections H-11, H-12, H-13, M-01, M-02, M-03, A-01)
@.planning/phases/03.1-audit-fixes-architectural-wiring/03.1-RESEARCH.md (sections "Fix 4", "Fix 5", "Fix 6")
@src/astraea/profiling/profiler.py
@src/astraea/io/xpt_writer.py
@src/astraea/transforms/dates.py
@src/astraea/transforms/usubjid.py
@src/astraea/mapping/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix profiler date disambiguation and XPT writer gaps</name>
  <files>
    src/astraea/profiling/profiler.py
    src/astraea/io/xpt_writer.py
  </files>
  <action>
**1. Fix profiler detect_date_format (profiler.py lines 75-104):**

Replace the _DATE_PATTERNS list and detect_date_format function. The current code has both "DD/MM/YYYY" and "MM/DD/YYYY" with IDENTICAL regex, so MM/DD/YYYY can never be returned (it's dead code).

Replace lines 75-82 with:
```python
_DATE_PATTERNS: list[tuple[str, re.Pattern[str]]] = [
    ("DD Mon YYYY", re.compile(r"^\d{1,2}\s+[A-Za-z]{3}\s+\d{4}$")),
    ("YYYY-MM-DD", re.compile(r"^\d{4}-\d{1,2}-\d{1,2}$")),
    ("DD-Mon-YYYY", re.compile(r"^\d{1,2}-[A-Za-z]{3}-\d{4}$")),
    ("YYYY-MM-DDTHH:MM:SS", re.compile(r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}")),
    ("SLASH_DATE", re.compile(r"^\d{1,2}/\d{1,2}/\d{4}$")),
]
```

In detect_date_format(), after the existing loop that matches patterns, add disambiguation logic for SLASH_DATE:
```python
if format_name == "SLASH_DATE":
    # Disambiguate DD/MM/YYYY vs MM/DD/YYYY by checking if any first-part values exceed 12
    for s in samples:
        s = s.strip()
        m = re.match(r"^(\d{1,2})/(\d{1,2})/(\d{4})$", s)
        if m:
            first, second = int(m.group(1)), int(m.group(2))
            if first > 12:
                return "DD/MM/YYYY"
            if second > 12:
                return "MM/DD/YYYY"
    # All ambiguous -- default to DD/MM/YYYY per project convention (D-0104-01)
    return "DD/MM/YYYY"
```

**2. Add XPT writer dataset label validation (xpt_writer.py):**

Add `table_label: str | None = None` parameter to both `validate_for_xpt_v5()` and `write_xpt_v5()`.

In validate_for_xpt_v5(), add these checks:
```python
# Table label validation
if table_label is not None and len(table_label) > 40:
    errors.append(
        f"Table label exceeds 40 characters ({len(table_label)} chars): "
        f"'{table_label[:50]}...'"
    )

# Unlabeled column warning
for col in df.columns:
    col_str = str(col)
    if col_str not in column_labels:
        # Case-insensitive fallback
        if col_str.upper() not in {k.upper() for k in column_labels}:
            errors.append(
                f"Column '{col_str}' has no label defined -- "
                f"every SDTM variable must have a label"
            )
```

In write_xpt_v5():
- Add `table_label: str | None = None` parameter
- Pass `table_label` to validate_for_xpt_v5()
- Pass `table_label` to pyreadstat.write_xport() if not None:
```python
write_kwargs = dict(
    table_name=upper_table,
    column_labels=upper_labels,
    file_format_version=5,
)
if table_label is not None:
    write_kwargs["table_label"] = table_label
pyreadstat.write_xport(df_out, str(path), **write_kwargs)
```
  </action>
  <verify>
Run: `python -c "from astraea.profiling.profiler import detect_date_format; print(detect_date_format(['03/15/2022', '12/25/2021']))"` -- should print "MM/DD/YYYY" (15 > 12 means first part is day, but 03 < 12 AND 15 > 12 means second part exceeds 12, so MM/DD/YYYY).
Wait -- let me reconsider. 03/15/2022: first=03, second=15. second > 12, so this IS MM/DD/YYYY. Correct.
Run: `python -c "from astraea.profiling.profiler import detect_date_format; print(detect_date_format(['15/03/2022', '25/12/2021']))"` -- should print "DD/MM/YYYY" (15 > 12 means first part is day).
  </verify>
  <done>Profiler correctly disambiguates slash dates. XPT writer validates dataset labels and warns about unlabeled columns.</done>
</task>

<task type="auto">
  <name>Task 2: Fix docstrings, add error wrapping, create transform registry</name>
  <files>
    src/astraea/transforms/dates.py
    src/astraea/mapping/engine.py
    src/astraea/mapping/transform_registry.py
  </files>
  <action>
**1. Fix dates.py docstring examples (lines ~115-116 and ~145-146):**

Line 115: Change `sas_date_to_iso(22739.0)` example.
The actual correct values:
- SAS date 22739 = 1960-01-01 + 22739 days = 2022-04-04
- The docstring claims '2022-03-30' which is wrong
- Fix: Change to `sas_date_to_iso(22734.0)` -> `'2022-03-30'` OR change the expected output to `'2022-04-04'`
- Simplest: Change the example to use a known correct pair. Use: `sas_date_to_iso(0.0)` -> `'1960-01-01'` (already in docstring) and update the first example to: `sas_date_to_iso(22734.0)` -> `'2022-03-30'`

Line 145: Change `sas_datetime_to_iso(1964217600.0)` example.
The actual value: 1960-01-01 + 1964217600 seconds = ?
- 1964217600 / 86400 = 22735.852... days = 1960-01-01 + 22735 days â‰ˆ 2022-03-31
- The docstring claims '2022-03-15T00:00:00' which is wrong
- Fix: Change to use a correct pair. Use: `sas_datetime_to_iso(1963526400.0)` -> `'2022-03-23T00:00:00'` or just compute the correct value for 2022-03-30: (22734 * 86400) = 1964937600.0 -> '2022-03-30T00:00:00'
- Safest: Compute correct pairs in a Python REPL first, then use them.

IMPORTANT: Run `python -c "from astraea.transforms.dates import sas_date_to_iso, sas_datetime_to_iso; print(sas_date_to_iso(22739.0)); print(sas_datetime_to_iso(1964217600.0))"` first to see actual outputs, then update docstrings to match.

**2. Add domain-specific error wrapping to engine.py (around line 137):**

Wrap the LLM call in a try/except that adds domain context:
```python
try:
    proposal = self._llm.parse(
        model=model,
        messages=[{"role": "user", "content": full_prompt}],
        system=MAPPING_SYSTEM_PROMPT,
        output_format=DomainMappingProposal,
        temperature=temperature,
        max_tokens=max_tokens,
    )
except Exception as e:
    msg = f"LLM mapping call failed for domain '{domain}': {e}"
    logger.error(msg)
    raise RuntimeError(msg) from e
```

**3. Create transform registry module (NEW file):**

Create `src/astraea/mapping/transform_registry.py`:
```python
"""Registry of available deterministic transforms for mapping specs.

Makes transform function signatures discoverable by the mapping engine
so that derivation_rule references can be validated against actual
available transforms. This module is the production code import path
for the transforms/ package.
"""

from __future__ import annotations

from typing import Callable

from astraea.transforms.dates import (
    format_partial_iso8601,
    parse_string_date_to_iso,
    sas_date_to_iso,
    sas_datetime_to_iso,
)
from astraea.transforms.usubjid import (
    generate_usubjid,
    generate_usubjid_column,
)

AVAILABLE_TRANSFORMS: dict[str, Callable] = {
    "sas_date_to_iso": sas_date_to_iso,
    "sas_datetime_to_iso": sas_datetime_to_iso,
    "parse_string_date_to_iso": parse_string_date_to_iso,
    "format_partial_iso8601": format_partial_iso8601,
    "generate_usubjid": generate_usubjid,
    "generate_usubjid_column": generate_usubjid_column,
}


def get_transform(name: str) -> Callable | None:
    """Look up a transform function by name.

    Args:
        name: Transform function name (e.g., "sas_date_to_iso").

    Returns:
        The callable transform function, or None if not found.
    """
    return AVAILABLE_TRANSFORMS.get(name)


def list_transforms() -> list[str]:
    """Return names of all registered transforms.

    Returns:
        Sorted list of transform function names.
    """
    return sorted(AVAILABLE_TRANSFORMS.keys())
```

This creates the production import path from mapping/ to transforms/, resolving architectural gap A-01.
  </action>
  <verify>
Run: `python -c "from astraea.mapping.transform_registry import list_transforms; print(list_transforms())"` -- should print 6 transform names.
Run: `python -c "from astraea.mapping.transform_registry import get_transform; fn = get_transform('sas_date_to_iso'); print(fn(0.0))"` -- should print '1960-01-01'.
Run: `ruff check src/astraea/transforms/dates.py src/astraea/mapping/engine.py src/astraea/mapping/transform_registry.py` -- clean.
  </verify>
  <done>Docstrings corrected, LLM errors wrapped with domain context, transform registry created bridging transforms/ to production code</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for all fixes</name>
  <files>
    tests/unit/profiling/test_profiler.py
    tests/unit/io/test_xpt_writer.py
    tests/unit/transforms/test_dates.py
    tests/unit/mapping/test_transform_registry.py
  </files>
  <action>
**1. Profiler date disambiguation tests (test_profiler.py):**
- Test detect_date_format(["15/03/2022", "25/12/2021"]) == "DD/MM/YYYY" (first > 12)
- Test detect_date_format(["03/15/2022", "12/25/2021"]) == "MM/DD/YYYY" (second > 12)
- Test detect_date_format(["03/04/2022", "01/02/2021"]) == "DD/MM/YYYY" (ambiguous, default)
- Test detect_date_format(["30 Mar 2022"]) == "DD Mon YYYY" (non-slash patterns still work)

**2. XPT writer tests (test_xpt_writer.py):**
- Test validate_for_xpt_v5 with table_label > 40 chars returns error
- Test validate_for_xpt_v5 with table_label <= 40 chars returns no error for that check
- Test validate_for_xpt_v5 with unlabeled column returns error mentioning the column name
- Test validate_for_xpt_v5 with all columns labeled returns no unlabeled-column error
- Test that table_label=None (backward compat) still works fine

**3. Docstring test (test_dates.py):**
- Run doctest on dates.py OR add explicit test that the example values in docstrings match actual output. Check `sas_date_to_iso()` and `sas_datetime_to_iso()` examples produce the documented output.

**4. Transform registry tests (NEW file: test_transform_registry.py):**
- Test list_transforms() returns 6 items
- Test get_transform("sas_date_to_iso") is not None and is callable
- Test get_transform("nonexistent") returns None
- Test that each registered transform is actually callable (parametrized)
- Test get_transform("sas_date_to_iso")(0.0) == "1960-01-01"

**5. Run full test suite:** `pytest -x -q`
  </action>
  <verify>`pytest tests/unit/profiling/test_profiler.py tests/unit/io/test_xpt_writer.py tests/unit/transforms/test_dates.py tests/unit/mapping/test_transform_registry.py -v` -- all pass. `pytest -x -q` -- full suite passes.</verify>
  <done>All fixes verified by tests: date disambiguation, XPT label validation, docstring accuracy, transform registry, full suite passes</done>
</task>

</tasks>

<verification>
- `pytest -x -q` passes
- `ruff check src/ tests/` passes
- `python -c "from astraea.mapping.transform_registry import list_transforms; print(len(list_transforms()))"` prints 6
</verification>

<success_criteria>
- Profiler correctly returns "MM/DD/YYYY" when appropriate (no more dead code)
- XPT writer catches oversized dataset labels and unlabeled columns
- dates.py docstring examples match actual outputs
- Engine wraps LLM errors with domain context
- transforms/ has production import path via transform_registry.py
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-audit-fixes-architectural-wiring/03.1-05-SUMMARY.md`
</output>
