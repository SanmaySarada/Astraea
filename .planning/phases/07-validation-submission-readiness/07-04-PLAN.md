---
phase: 07-validation-submission-readiness
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/astraea/validation/predict.py
  - src/astraea/mapping/engine.py
  - src/astraea/models/mapping.py
  - tests/unit/validation/test_predict.py
autonomous: true

must_haves:
  truths:
    - "Validation rules run DURING mapping before human review (predict-and-prevent)"
    - "Predict-and-prevent catches missing required variables, invalid CT codes, duplicate mappings, and unknown SDTM variables at spec time"
    - "Mapping engine integrates predict-and-prevent results into DomainMappingSpec.predict_prevent_issues field"
  artifacts:
    - path: "src/astraea/validation/predict.py"
      provides: "Predict-and-prevent validation that runs on mapping specs (no data needed)"
      contains: "def predict_and_prevent"
  key_links:
    - from: "src/astraea/validation/predict.py"
      to: "src/astraea/models/mapping.py"
      via: "operates on DomainMappingSpec and VariableMapping"
      pattern: "DomainMappingSpec"
    - from: "src/astraea/mapping/engine.py"
      to: "src/astraea/validation/predict.py"
      via: "calls predict_and_prevent after building spec"
      pattern: "from astraea\\.validation\\.predict import"
    - from: "src/astraea/models/mapping.py"
      to: "human review display"
      via: "predict_prevent_issues field on DomainMappingSpec"
      pattern: "predict_prevent_issues"
---

<objective>
Implement predict-and-prevent validation (VAL-06): lightweight rules that run on mapping specs BEFORE dataset generation, catching issues early so they can be fixed during human review.

Purpose: Shift validation left -- detect problems at mapping time, not after expensive dataset generation.
Output: validation/predict.py with spec-level checks, wired into mapping/engine.py, results stored on DomainMappingSpec
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-validation-submission-readiness/07-RESEARCH.md
@src/astraea/validation/rules/base.py
@src/astraea/mapping/engine.py
@src/astraea/mapping/validation.py
@src/astraea/models/mapping.py
@src/astraea/models/sdtm.py
@src/astraea/reference/sdtm_ig.py
@src/astraea/reference/controlled_terms.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Predict-and-prevent rules</name>
  <files>
    src/astraea/validation/predict.py
    src/astraea/models/mapping.py
    tests/unit/validation/test_predict.py
  </files>
  <action>
**First, add predict_prevent_issues field to DomainMappingSpec in models/mapping.py:**

Add to the DomainMappingSpec class:
```python
predict_prevent_issues: list[dict] = Field(
    default_factory=list,
    description="Predict-and-prevent validation issues found at spec time. Each dict has: rule_id, severity, domain, variable (optional), message, fix_suggestion (optional). Populated by validation/predict.py and surfaced during human review."
)
```

Use `list[dict]` rather than `list[RuleResult]` to avoid a circular import from models -> validation. Each dict mirrors RuleResult fields: rule_id, severity (str: "ERROR"/"WARNING"/"NOTICE"), domain, variable (str|None), message, fix_suggestion (str|None).

**predict.py** -- Spec-level validation that requires NO generated data:

`predict_and_prevent(spec: DomainMappingSpec, domain_spec: DomainSpec, ct_ref: CTReference) -> list[RuleResult]`:
Runs all spec-level checks and returns RuleResult objects. Checks:

1. **Required variables present** (rule_id="ASTR-PP001"): All Required (core==REQ) variables from domain_spec have a mapping in spec.variable_mappings. Severity: ERROR. This overlaps with mapping/validation.py check_required_coverage() but produces formal RuleResult objects.

2. **No duplicate variable mappings** (rule_id="ASTR-PP002"): No two mappings target the same sdtm_variable. Severity: ERROR.

3. **CT codelist codes valid** (rule_id="ASTR-PP003"): For each mapping with codelist_code, verify the codelist exists in ct_ref. Severity: WARNING (missing codelist is reference gap, not mapping error).

4. **ASSIGN values in non-extensible codelists** (rule_id="ASTR-PP004"): For ASSIGN pattern with codelist_code, verify assigned_value is a valid term in non-extensible codelists. Severity: ERROR for non-extensible violations.

5. **Variable names in SDTM-IG** (rule_id="ASTR-PP005"): All mapped sdtm_variable names should exist in domain_spec.variables. Severity: WARNING for unknown variables (may be valid SUPPQUAL candidates).

6. **Origin field populated** (rule_id="ASTR-PP006"): All mappings should have origin set (CRF, Derived, Assigned, etc.). Severity: NOTICE if missing (needed for define.xml but not blocking).

7. **Computational method for derived variables** (rule_id="ASTR-PP007"): For DERIVATION pattern mappings, computational_method should be populated. Severity: NOTICE if missing (needed for define.xml MethodDef).

Also add a helper function:
`results_to_issue_dicts(results: list[RuleResult]) -> list[dict]`:
Converts RuleResult objects to plain dicts suitable for storing on DomainMappingSpec.predict_prevent_issues. Maps: rule_id, severity (str value), domain, variable, message, fix_suggestion.

**Tests**: Create synthetic DomainMappingSpec objects with known issues (duplicate variables, bad CT codes, missing required vars, ASSIGN with wrong CT values). Verify each check independently. Verify returned RuleResult objects have correct rule_ids, severities, and messages. Test results_to_issue_dicts produces correct dict format.
  </action>
  <verify>pytest tests/unit/validation/test_predict.py -x -q</verify>
  <done>Predict-and-prevent catches 7 types of spec-level issues before dataset generation; results convertible to dict format for DomainMappingSpec</done>
</task>

<task type="auto">
  <name>Task 2: Wire predict-and-prevent into mapping engine</name>
  <files>
    src/astraea/mapping/engine.py
  </files>
  <action>
Read the existing mapping/engine.py first. Then add predict-and-prevent integration:

1. Add import: `from astraea.validation.predict import predict_and_prevent, results_to_issue_dicts`
2. In the MappingEngine class, after the existing validate_and_enrich step that produces the DomainMappingSpec, add a call to `predict_and_prevent()` to get formal validation results.
3. **Store results on the spec object**: Call `results_to_issue_dicts(pp_results)` and assign to `spec.predict_prevent_issues`. This makes the issues available to any downstream consumer (human review display, cSDRG generation, etc.) without requiring a separate return channel.
4. Log any ERROR-level issues from predict_and_prevent using loguru: `logger.warning(f"Predict-and-prevent found {error_count} errors for {spec.domain}")`.
5. Do NOT block mapping on predict-and-prevent failures -- these are informational for human review. Log warnings, include in output via the spec field.

IMPORTANT: Do not break the existing mapping pipeline. This is additive. If predict_and_prevent import fails (e.g., during testing without validation module), catch ImportError and skip gracefully.

Verify: Run existing mapping tests to confirm no regression: `pytest tests/unit/mapping/ -x -q`
  </action>
  <verify>pytest tests/unit/mapping/ tests/unit/validation/test_predict.py -x -q</verify>
  <done>Mapping engine calls predict-and-prevent after building spec; results stored in spec.predict_prevent_issues; existing mapping tests still pass</done>
</task>

</tasks>

<verification>
- `pytest tests/unit/validation/ tests/unit/mapping/ -x -q` -- all tests pass
- `ruff check src/astraea/validation/predict.py src/astraea/mapping/engine.py src/astraea/models/mapping.py`
- predict_and_prevent returns formal RuleResult objects for 7 check types
- DomainMappingSpec.predict_prevent_issues populated after mapping engine runs
</verification>

<success_criteria>
- VAL-06: Predict-and-prevent validates mapping specs before dataset generation
- 7 spec-level checks implemented with appropriate severity levels
- Results stored on DomainMappingSpec.predict_prevent_issues as list[dict] for downstream consumption
- Mapping engine integrates predict-and-prevent without breaking existing pipeline
- 10+ unit tests for predict-and-prevent rules
</success_criteria>

<output>
After completion, create `.planning/phases/07-validation-submission-readiness/07-04-SUMMARY.md`
</output>
