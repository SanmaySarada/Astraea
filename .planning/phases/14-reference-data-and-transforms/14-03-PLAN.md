---
phase: 14-reference-data-and-transforms
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/transforms/char_length.py
  - src/astraea/transforms/epoch.py
  - src/astraea/transforms/recoding.py
  - src/astraea/transforms/visit.py
  - tests/unit/transforms/test_char_length_phase14.py
  - tests/unit/transforms/test_epoch_phase14.py
  - tests/unit/transforms/test_recoding_phase14.py
  - tests/unit/transforms/test_visit_phase14.py
autonomous: true

must_haves:
  truths:
    - "Character values exceeding 200 bytes are detected and reported"
    - "Overlapping SE epoch elements are detected per subject"
    - "SEX raw values (Male, Female, M, F, 1, 2) recode to C66731 terms"
    - "RACE raw values recode to C74457 terms"
    - "ETHNIC raw values recode to C66790 terms"
    - "TV domain data can generate visit_mapping dict for assign_visit"
    - "iterrows in epoch.py and visit.py replaced with vectorized operations"
  artifacts:
    - path: "src/astraea/transforms/char_length.py"
      provides: "200-byte max validation function"
      contains: "validate_char_max_length"
    - path: "src/astraea/transforms/epoch.py"
      provides: "Overlap detection + vectorized SE grouping"
      contains: "detect_epoch_overlaps"
    - path: "src/astraea/transforms/recoding.py"
      provides: "SEX, RACE, ETHNIC recoding wrappers"
      contains: "recode_sex"
    - path: "src/astraea/transforms/visit.py"
      provides: "TV domain integration + vectorized visit assignment"
      contains: "build_visit_mapping_from_tv"
  key_links:
    - from: "src/astraea/transforms/recoding.py"
      to: "src/astraea/data/ct/codelists.json"
      via: "Recoding maps match codelist submission values"
      pattern: "recode_sex|recode_race|recode_ethnic"
---

<objective>
Add missing transform utilities: 200-byte char validation, epoch overlap detection, SEX/RACE/ETHNIC recoding wrappers, TV domain visit mapping, and vectorize iterrows in epoch.py/visit.py.

Purpose: These utilities fill gaps in the transform layer needed for complete SDTM dataset generation and validation.
Output: Enhanced char_length.py, epoch.py, recoding.py, visit.py with new functions and vectorized internals.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-reference-data-and-transforms/14-RESEARCH.md
@src/astraea/transforms/char_length.py
@src/astraea/transforms/epoch.py
@src/astraea/transforms/recoding.py
@src/astraea/transforms/visit.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: 200-byte validation + epoch overlap detection (MED-22, MED-23)</name>
  <files>src/astraea/transforms/char_length.py, src/astraea/transforms/epoch.py, tests/unit/transforms/test_char_length_phase14.py, tests/unit/transforms/test_epoch_phase14.py</files>
  <action>
  Two additions:

  1. **200-byte max validation in char_length.py** -- MED-22:
     Add `validate_char_max_length(df: pd.DataFrame, max_bytes: int = 200) -> dict[str, list[int]]` function.
     - Iterates over string/object columns in the DataFrame
     - For each column, encodes non-null values to ASCII (errors="replace") and checks byte length
     - Returns dict mapping column name to list of row indices where values exceed max_bytes
     - Returns empty dict if no violations
     - Also update `optimize_char_lengths()` (if it exists) to cap computed widths at 200

  2. **Epoch overlap detection in epoch.py** -- MED-23:
     Add `detect_epoch_overlaps(se_df: pd.DataFrame, usubjid_col: str = "USUBJID") -> list[dict]` function.
     - Groups SE data by USUBJID
     - For each subject, sorts by SESTDTC and checks for overlapping date ranges
     - CRITICAL: Adjacent elements (SEENDTC == SESTDTC of next) are NOT overlaps. Use strict less-than: `start_B < end_A` (not <=)
     - Returns list of dicts with keys: usubjid, epoch_1, epoch_2, overlap_start, overlap_end
     - Returns empty list if no overlaps found
     - Open-ended elements (no SEENDTC) extend to infinity for overlap checking

     Also **vectorize the existing iterrows in epoch.py** (MED-02 partial):
     - Replace the SE data pre-grouping iterrows loop with `se_df.to_dict("records")` + dict comprehension
     - Keep the same behavior, just faster execution

  **Tests** in `tests/unit/transforms/test_char_length_phase14.py`:
  - test_no_violations: DataFrame with all values < 200 bytes -> empty dict
  - test_single_violation: One column with one value > 200 bytes -> {col: [row_idx]}
  - test_multiple_columns: Multiple columns with violations -> correct dict
  - test_numeric_columns_ignored: Numeric columns not checked
  - test_null_values_skipped: None/NaN values not flagged
  - test_custom_max_bytes: max_bytes=100 catches 101-byte values

  **Tests** in `tests/unit/transforms/test_epoch_phase14.py`:
  - test_no_overlaps: Sequential epochs -> empty list
  - test_overlapping_epochs: Two epochs with overlapping dates -> detected
  - test_adjacent_not_overlapping: End == Start of next -> NOT flagged
  - test_open_ended_epoch: No SEENDTC -> extends to infinity, overlaps with next
  - test_multiple_subjects: Overlaps per subject, independent
  - test_empty_df: Empty DataFrame -> empty list
  </action>
  <verify>
  ```bash
  cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/test_char_length_phase14.py tests/unit/transforms/test_epoch_phase14.py -xvs
  ```
  </verify>
  <done>200-byte validation catches oversized character values. Epoch overlap detection correctly identifies overlapping SE elements. Epoch iterrows replaced with vectorized operations.</done>
</task>

<task type="auto">
  <name>Task 2: SEX/RACE/ETHNIC recoding + TV visit mapping (MED-25, MED-24)</name>
  <files>src/astraea/transforms/recoding.py, src/astraea/transforms/visit.py, tests/unit/transforms/test_recoding_phase14.py, tests/unit/transforms/test_visit_phase14.py</files>
  <action>
  Two additions:

  1. **SEX, RACE, ETHNIC recoding wrappers in recoding.py** -- MED-25:

     Add three functions with comprehensive input handling (case-insensitive, numeric codes, abbreviations):

     ```python
     def recode_sex(value: object) -> str | None:
         """Recode raw sex values to C66731 submission values (M/F/U/UNDIFFERENTIATED)."""
     ```
     Map: "male"/"m"/"1" -> "M", "female"/"f"/"2" -> "F", "unknown"/"u" -> "U", "undifferentiated" -> "UNDIFFERENTIATED". None/NaN -> None. Unrecognized -> None.

     ```python
     def recode_race(value: object) -> str | None:
         """Recode raw race values to C74457 submission values."""
     ```
     Map: "white"/"caucasian"/"1" -> "WHITE", "black"/"african american"/"2" -> "BLACK OR AFRICAN AMERICAN", "asian"/"3" -> "ASIAN", "american indian"/"native american"/"4" -> "AMERICAN INDIAN OR ALASKA NATIVE", "native hawaiian"/"pacific islander"/"5" -> "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER", "other"/"6" -> "OTHER", "multiple"/"mixed"/"7" -> "MULTIPLE". None/NaN -> None. Unrecognized -> None.

     ```python
     def recode_ethnic(value: object) -> str | None:
         """Recode raw ethnicity values to C66790 submission values."""
     ```
     Map: "hispanic"/"hispanic or latino"/"latino"/"1" -> "HISPANIC OR LATINO", "not hispanic"/"not hispanic or latino"/"2" -> "NOT HISPANIC OR LATINO", "unknown"/"u"/"3" -> "UNKNOWN", "not reported"/"nr"/"4" -> "NOT REPORTED". None/NaN -> None. Unrecognized -> None.

     All functions: strip whitespace, lowercase before lookup, return None for unrecognized values (never raise).

  2. **TV domain visit mapping in visit.py** -- MED-24:

     Add `build_visit_mapping_from_tv(tv_df: pd.DataFrame) -> dict[str, tuple[float, str]]` function.
     - Reads TV domain DataFrame with columns VISITNUM, VISIT, ARMCD (optional)
     - Returns dict mapping VISIT name -> (VISITNUM, VISIT) for use with `assign_visit()`
     - If TV has ARMCD, use only rows where ARMCD matches (or use the first arm if not specified)
     - Falls back gracefully if TV columns are missing

     Also **vectorize the existing iterrows in visit.py** (MED-02 partial):
     - Replace any iterrows loop with vectorized DataFrame merge or map operations

  **Tests** in `tests/unit/transforms/test_recoding_phase14.py`:
  - test_recode_sex_male_variants: "Male", "male", "M", "m", "1" -> "M"
  - test_recode_sex_female_variants: "Female", "female", "F", "f", "2" -> "F"
  - test_recode_sex_unknown: "Unknown", "U" -> "U"
  - test_recode_sex_none: None -> None
  - test_recode_sex_unrecognized: "other" -> None
  - test_recode_sex_whitespace: " Male " -> "M"
  - test_recode_race_standard: "White" -> "WHITE", "Asian" -> "ASIAN"
  - test_recode_race_aliases: "african american" -> "BLACK OR AFRICAN AMERICAN"
  - test_recode_race_numeric: "1" -> "WHITE"
  - test_recode_race_none: None -> None
  - test_recode_ethnic_standard: "Hispanic or Latino" -> "HISPANIC OR LATINO"
  - test_recode_ethnic_short: "hispanic" -> "HISPANIC OR LATINO"
  - test_recode_ethnic_numeric: "2" -> "NOT HISPANIC OR LATINO"
  - test_recode_ethnic_none: None -> None

  **Tests** in `tests/unit/transforms/test_visit_phase14.py`:
  - test_build_visit_mapping_basic: TV with VISITNUM/VISIT -> correct mapping
  - test_build_visit_mapping_empty: Empty TV -> empty dict
  - test_build_visit_mapping_missing_columns: TV without VISIT column -> empty dict gracefully
  </action>
  <verify>
  ```bash
  cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/test_recoding_phase14.py tests/unit/transforms/test_visit_phase14.py -xvs
  ```
  </verify>
  <done>SEX/RACE/ETHNIC recoding handles all common input variants. TV visit mapping generates dict from TV domain data. visit.py iterrows replaced with vectorized operations.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/ -x -q --timeout=30 2>&1 | tail -5
```
All existing transform tests plus new tests pass.
</verification>

<success_criteria>
- validate_char_max_length detects values exceeding 200 bytes
- detect_epoch_overlaps finds overlapping SE elements, adjacent boundaries not flagged
- recode_sex/race/ethnic handle all common raw value variants
- build_visit_mapping_from_tv generates mapping from TV domain
- iterrows in epoch.py and visit.py replaced with vectorized operations
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-reference-data-and-transforms/14-03-SUMMARY.md`
</output>
