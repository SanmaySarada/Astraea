---
phase: 14-reference-data-and-transforms
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/transforms/dates.py
  - src/astraea/validation/rules/format.py
  - src/astraea/transforms/imputation.py
  - tests/unit/transforms/test_dates_phase14.py
  - tests/unit/transforms/test_imputation_phase14.py
autonomous: true

must_haves:
  truths:
    - "ISO 8601 dates with timezone offsets pass validation"
    - "parse_string_date_to_iso passes through ISO datetime strings unchanged"
    - "DD Mon YYYY HH:MM:SS format with seconds is correctly parsed"
    - "Partial dates can be imputed to first/last/mid of missing components"
  artifacts:
    - path: "src/astraea/transforms/dates.py"
      provides: "ISO datetime passthrough, HH:MM:SS support"
      contains: "_PATTERN_ISO_DATETIME"
    - path: "src/astraea/validation/rules/format.py"
      provides: "ISO 8601 regex with timezone support"
      contains: "Z|[+-]"
    - path: "src/astraea/transforms/imputation.py"
      provides: "impute_partial_date function"
      contains: "impute_partial_date"
  key_links:
    - from: "src/astraea/validation/rules/format.py"
      to: "src/astraea/transforms/dates.py"
      via: "Both handle ISO 8601 format consistency"
      pattern: "ISO.?8601"
---

<objective>
Fix date/time handling gaps: timezone offset support in validation, ISO datetime passthrough, HH:MM:SS seconds parsing, and date imputation functions.

Purpose: Clinical data contains timezone-aware timestamps and partial dates that need imputation. Without these fixes, valid dates fail validation and partial dates cannot be imputed for analysis.
Output: Updated dates.py (3 fixes), format.py (timezone regex), imputation.py (impute_partial_date function).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-reference-data-and-transforms/14-RESEARCH.md
@src/astraea/transforms/dates.py
@src/astraea/validation/rules/format.py
@src/astraea/transforms/imputation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: ISO 8601 timezone + datetime passthrough + HH:MM:SS (MED-03, MED-19, MED-20)</name>
  <files>src/astraea/transforms/dates.py, src/astraea/validation/rules/format.py, tests/unit/transforms/test_dates_phase14.py</files>
  <action>
  Three date/time fixes:

  1. **ISO 8601 timezone offset in format.py** -- MED-03:
     Update the `_ISO_8601_PATTERN` regex in `format.py` to accept optional timezone suffixes (Z, +HH:MM, -HH:MM) after the time component. The timezone group must only appear when there IS a time component (after T). Updated regex:
     ```python
     _ISO_8601_PATTERN = re.compile(
         r"^\d{4}"
         r"(-\d{2}"
         r"(-\d{2}"
         r"(T\d{2}"
         r"(:\d{2}"
         r"(:\d{2})?"
         r")?"
         r"(Z|[+-]\d{2}:\d{2})?"
         r")?"
         r")?"
         r")?"
         r"$"
     )
     ```
     CRITICAL: Ensure the timezone group is INSIDE the T-group (only valid with time), not outside.

  2. **ISO datetime passthrough in dates.py** -- MED-20:
     Add a new regex `_PATTERN_ISO_DATETIME` to dates.py that matches `YYYY-MM-DDTHH:MM(:SS)?` with optional timezone suffix. Place the check in `parse_string_date_to_iso()` BEFORE the existing `_PATTERN_YYYY_MM_DD` check. When matched, return the input string as-is (passthrough). Pattern:
     ```python
     _PATTERN_ISO_DATETIME = re.compile(
         r"^\s*(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?"
         r"(?:Z|[+-]\d{2}:\d{2})?\s*$"
     )
     ```

  3. **HH:MM:SS seconds support in dates.py** -- MED-19:
     Update the `_PATTERN_DD_MON_YYYY_HHMM` regex (or its equivalent) to support optional seconds. Change `(\d{1,2}):(\d{2})` to `(\d{1,2}):(\d{2})(?::(\d{2}))?`. When seconds are present, include them in the ISO output: `YYYY-MM-DDTHH:MM:SS`. If only HH:MM, keep existing behavior: `YYYY-MM-DDTHH:MM`.

  4. **Tests** in `tests/unit/transforms/test_dates_phase14.py`:
     - `test_iso_datetime_passthrough`: "2022-03-30T14:30:00" -> "2022-03-30T14:30:00"
     - `test_iso_datetime_passthrough_with_tz`: "2022-03-30T14:30:00Z" -> "2022-03-30T14:30:00Z"
     - `test_iso_datetime_passthrough_offset`: "2022-03-30T14:30:00+05:30" -> "2022-03-30T14:30:00+05:30"
     - `test_iso_datetime_passthrough_hhmm_only`: "2022-03-30T14:30" -> "2022-03-30T14:30"
     - `test_dd_mon_yyyy_hhmmss`: "30 Mar 2022 14:30:45" -> "2022-03-30T14:30:45"
     - `test_dd_mon_yyyy_hhmm_still_works`: "30 Mar 2022 14:30" -> "2022-03-30T14:30"
     - `test_iso_tz_passes_validation`: Validate that the format rule accepts "2022-03-30T14:30:00Z", "2022-03-30T14:30:00+05:30", "2022-03-30T14:30:00-04:00"
     - `test_plain_dates_still_pass_validation`: "2022-03-30", "2022-03", "2022" still pass format validation
     - `test_existing_date_formats_unbroken`: Run a few existing date format tests to ensure no regression
  </action>
  <verify>
  ```bash
  cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/test_dates_phase14.py -xvs
  ```
  </verify>
  <done>ISO datetime passthrough works, HH:MM:SS seconds parsed, timezone offsets accepted in validation. No regression in existing date handling.</done>
</task>

<task type="auto">
  <name>Task 2: Date imputation functions (MED-21)</name>
  <files>src/astraea/transforms/imputation.py, tests/unit/transforms/test_imputation_phase14.py</files>
  <action>
  Add `impute_partial_date()` function to `imputation.py` alongside existing flag detection functions.

  Function signature:
  ```python
  def impute_partial_date(
      partial_dtc: str,
      method: str = "first",
  ) -> str:
      """Impute missing components of a partial ISO 8601 date.

      Args:
          partial_dtc: Partial ISO 8601 date (e.g., "2022", "2022-03", "2022-03-30T14")
          method: Imputation method - "first" (Jan 1 / 00:00:00), "last" (Dec 31 / 23:59:59),
                  "mid" (Jun 15 / 12:00:00)

      Returns:
          Fully imputed ISO 8601 date string. Returns input unchanged if already complete.
          Returns empty string for empty/null input.
      """
  ```

  Imputation rules by method:
  - "first": Missing month -> 01, missing day -> 01, missing time -> T00:00:00
  - "last": Missing month -> 12, missing day -> last day of month (28/29/30/31), missing time -> T23:59:59
  - "mid": Missing month -> 06, missing day -> 15, missing time -> T12:00:00

  Input patterns to handle:
  - "2022" -> "2022-01-01T00:00:00" (first), "2022-12-31T23:59:59" (last), "2022-06-15T12:00:00" (mid)
  - "2022-03" -> "2022-03-01T00:00:00" (first), "2022-03-31T23:59:59" (last), "2022-03-15T12:00:00" (mid)
  - "2022-02" -> "2022-02-01" (first), "2022-02-28" (last, non-leap), "2022-02-15" (mid)
  - "2024-02" -> "2024-02-29" (last, leap year)
  - "2022-03-30" -> return as-is (date already complete, no time imputation needed unless time is missing and caller wants full datetime)
  - "2022-03-30T14" -> "2022-03-30T14:00:00" (first), "2022-03-30T14:59:59" (last)
  - "" or None -> ""

  Use `calendar.monthrange()` for last-day-of-month calculation.

  IMPORTANT: The function should only impute missing components, not add time to a complete date. "2022-03-30" returns "2022-03-30" unless the caller explicitly needs datetime.

  Also add a companion helper:
  ```python
  def impute_partial_date_with_flag(
      partial_dtc: str,
      method: str = "first",
  ) -> tuple[str, str | None, str | None]:
      """Impute partial date and return (imputed_date, dtf_flag, tmf_flag).

      Combines impute_partial_date with get_date_imputation_flag/get_time_imputation_flag.
      """
  ```

  **Tests** in `tests/unit/transforms/test_imputation_phase14.py`:
  - test_impute_year_only_first: "2022" -> "2022-01-01"
  - test_impute_year_only_last: "2022" -> "2022-12-31"
  - test_impute_year_only_mid: "2022" -> "2022-06-15"
  - test_impute_year_month_first: "2022-03" -> "2022-03-01"
  - test_impute_year_month_last: "2022-03" -> "2022-03-31"
  - test_impute_year_month_last_feb_leap: "2024-02" -> "2024-02-29"
  - test_impute_year_month_last_feb_nonleap: "2022-02" -> "2022-02-28"
  - test_impute_complete_date_unchanged: "2022-03-30" -> "2022-03-30"
  - test_impute_with_time_hour_only: "2022-03-30T14" -> "2022-03-30T14:00:00" (first)
  - test_impute_empty_string: "" -> ""
  - test_impute_none: None -> ""
  - test_impute_with_flag: "2022-03" with first -> ("2022-03-01", "D", None)
  - test_impute_invalid_method_raises: method="invalid" -> ValueError
  </action>
  <verify>
  ```bash
  cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/test_imputation_phase14.py -xvs
  ```
  </verify>
  <done>impute_partial_date handles all partial date patterns with first/last/mid methods. impute_partial_date_with_flag combines imputation with flag generation. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/sanmaysarada/Astraea-SDTM && python3.12 -m pytest tests/unit/transforms/ -x -q --timeout=30 2>&1 | tail -5
```
All existing date/transform tests plus new tests pass.
</verification>

<success_criteria>
- ISO 8601 validation accepts timezone offsets (Z, +HH:MM, -HH:MM)
- parse_string_date_to_iso passes through ISO datetime strings
- DD Mon YYYY HH:MM:SS parsed correctly with seconds
- impute_partial_date works for all partial date patterns with first/last/mid methods
- No regression in existing date handling or format validation
</success_criteria>

<output>
After completion, create `.planning/phases/14-reference-data-and-transforms/14-02-SUMMARY.md`
</output>
