---
phase: 03-core-mapping-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/mapping/__init__.py
  - src/astraea/mapping/context.py
  - tests/unit/mapping/__init__.py
  - tests/unit/mapping/test_context.py
autonomous: true

must_haves:
  truths:
    - "Context builder produces a formatted prompt string from domain spec + profiles + eCRF + CT"
    - "EDC columns are filtered out -- only clinical variables appear in context"
    - "Only relevant CT codelists included (those referenced by domain variables)"
    - "Cross-domain source datasets are summarized in the context"
    - "Context fits within reasonable token budget (~3000-5000 tokens for DM)"
  artifacts:
    - path: "src/astraea/mapping/context.py"
      provides: "MappingContext builder and prompt formatter"
      contains: "class MappingContextBuilder"
    - path: "tests/unit/mapping/test_context.py"
      provides: "Unit tests for context assembly"
      min_lines: 60
  key_links:
    - from: "src/astraea/mapping/context.py"
      to: "src/astraea/reference/sdtm_ig.py"
      via: "SDTMReference.get_domain_spec()"
      pattern: "get_domain_spec"
    - from: "src/astraea/mapping/context.py"
      to: "src/astraea/reference/controlled_terms.py"
      via: "CTReference for codelist lookup"
      pattern: "CTReference"
---

<objective>
Build the context assembly module that gathers all relevant information for a domain and formats it into a structured prompt string for the LLM mapping call.

Purpose: The LLM needs focused, well-structured context to propose accurate mappings. This module prevents context window overflow by including only relevant data (clinical vars, matched codelists, domain-specific eCRF forms).
Output: `src/astraea/mapping/context.py` + unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-mapping-engine/03-RESEARCH.md

@src/astraea/reference/sdtm_ig.py
@src/astraea/reference/controlled_terms.py
@src/astraea/models/profiling.py
@src/astraea/models/ecrf.py
@src/astraea/models/sdtm.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mapping context builder</name>
  <files>src/astraea/mapping/__init__.py, src/astraea/mapping/context.py</files>
  <action>
Create `src/astraea/mapping/__init__.py` (empty initially, will grow as more components are added).

Create `src/astraea/mapping/context.py` with:

1. **MappingContextBuilder class:**
   - Constructor takes: `sdtm_ref: SDTMReference`, `ct_ref: CTReference`
   - Method `build_prompt(domain: str, source_profiles: list[DatasetProfile], ecrf_forms: list[ECRFForm], study_metadata: StudyMetadata, cross_domain_profiles: dict[str, DatasetProfile] | None = None) -> str`

2. **build_prompt logic:**
   a. Get domain spec from SDTMReference: `sdtm_ref.get_domain_spec(domain)`
   b. Format SDTM domain section: list all variables grouped by core (Req, Exp, Perm), showing name, label, type, codelist_code
   c. Format source data section: for each profile, show filename, row_count, then for each variable WHERE `is_edc_column == False`: name, label, dtype, n_unique, n_missing, sample_values (first 5)
   d. Format eCRF section: for each form, show form_name, then for each field: field_name, data_type, sas_label, coded_values
   e. Format CT section: collect all codelist_codes referenced by the domain's VariableSpecs, look each up via CTReference, and list codelist name, extensible flag, and all submission_values. If a codelist_code is None or not found, skip it.
   f. Format cross-domain sources section: if cross_domain_profiles provided, for each dataset show filename and clinical variable names+labels (summary, not full profile)
   g. Format study metadata section: study_id from StudyMetadata

3. **The prompt output should be a single string** with clear markdown-style sections (## headers) that the LLM system prompt references. Include:
   - "## SDTM Domain: {domain} ({description})"
   - "## Source Data"
   - "## eCRF Forms"
   - "## Controlled Terminology"
   - "## Cross-Domain Sources Available"
   - "## Study Metadata"

4. **Helper: `_get_relevant_codelists(domain_spec: DomainSpec, ct_ref: CTReference) -> dict[str, Codelist]`** -- collects only the CT codelists referenced by the domain's variables. Returns dict of codelist_code -> Codelist.

5. **Helper: `_format_variable_profile(vp: VariableProfile) -> str`** -- single-line summary of a variable for the prompt.

Import StudyMetadata from astraea.models.mapping (created in Plan 01). Since Plan 01 and 02 are Wave 1 (parallel), if mapping.py doesn't exist yet, define a minimal local StudyMetadata or use a dict. Prefer: just import it -- the executor will handle ordering within the wave if needed.
  </action>
  <verify>
    `python -c "from astraea.mapping.context import MappingContextBuilder; print('Context builder importable')"` succeeds.
  </verify>
  <done>Context builder assembles a focused prompt string from domain spec, profiles, eCRF, and CT data with EDC columns filtered out.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for context builder</name>
  <files>tests/unit/mapping/__init__.py, tests/unit/mapping/test_context.py</files>
  <action>
Create `tests/unit/mapping/__init__.py` (empty).

Create `tests/unit/mapping/test_context.py` with:

1. **Fixtures:** Create minimal DatasetProfile, ECRFForm, DomainSpec, and StudyMetadata fixtures for testing. Use the DM domain as the example.
   - DatasetProfile fixture: Include 3-4 clinical variables (AGE, SEX_STD, ETHNIC_STD) and 2 EDC variables (projectid, instanceId) with is_edc_column=True.
   - ECRFForm fixture: A "Demographics" form with 2-3 fields.
   - Use real SDTMReference and CTReference (loaded from bundled data) where practical; otherwise mock.

2. **Tests:**
   - `test_build_prompt_contains_domain_header`: Output contains "## SDTM Domain: DM"
   - `test_build_prompt_excludes_edc_columns`: Output does NOT contain "projectid" or "instanceId"
   - `test_build_prompt_includes_clinical_variables`: Output contains "AGE", "SEX_STD"
   - `test_build_prompt_includes_ct_codelists`: Output contains "C66731" (Sex codelist) or the codelist name
   - `test_build_prompt_includes_ecrf_fields`: Output contains eCRF field names
   - `test_build_prompt_includes_study_metadata`: Output contains the study_id
   - `test_get_relevant_codelists_filters_correctly`: Only returns codelists referenced by domain vars
   - `test_build_prompt_with_cross_domain`: Cross-domain profiles appear in output
   - `test_build_prompt_without_cross_domain`: Works fine when cross_domain_profiles is None

Use real SDTMReference and CTReference from bundled data for realistic tests.
  </action>
  <verify>`pytest tests/unit/mapping/test_context.py -v` -- all tests pass.</verify>
  <done>Context builder is tested with realistic DM domain data and correctly filters EDC columns.</done>
</task>

</tasks>

<verification>
- `ruff check src/astraea/mapping/ tests/unit/mapping/` -- no lint errors
- `pytest tests/unit/mapping/test_context.py -v` -- all tests pass
- `pytest tests/ -x -q` -- full test suite still passes (no regressions)
</verification>

<success_criteria>
MappingContextBuilder produces well-structured LLM prompts with only relevant context (clinical vars, domain-specific CT, matched eCRF forms), and EDC system columns are excluded.
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-mapping-engine/03-02-SUMMARY.md`
</output>
