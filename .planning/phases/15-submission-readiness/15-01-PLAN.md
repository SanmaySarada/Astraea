---
phase: 15-submission-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/execution/pattern_handlers.py
  - src/astraea/execution/findings.py
  - tests/unit/execution/test_split_pattern.py
  - tests/unit/execution/test_merge_horizontal.py
  - tests/unit/execution/test_findings_metadata.py
autonomous: true

must_haves:
  truths:
    - "SPLIT pattern handler produces correct values for SUBSTRING, DELIMITER_PART, and REGEX_GROUP derivation rules"
    - "Multi-source merge supports key-based horizontal joins on USUBJID/VISITNUM in addition to existing vertical concat"
    - "Findings executor populates specimen type, method, and fasting variables when present in source data"
  artifacts:
    - path: "src/astraea/execution/pattern_handlers.py"
      provides: "Functional SPLIT handler with SUBSTRING/DELIMITER_PART/REGEX_GROUP"
      contains: "SUBSTRING|DELIMITER_PART|REGEX_GROUP"
    - path: "src/astraea/execution/findings.py"
      provides: "Key-based merge and specimen/method/fasting pass-through"
      contains: "merge_mode|SPEC|METHOD|FAST"
    - path: "tests/unit/execution/test_split_pattern.py"
      provides: "SPLIT pattern unit tests"
      min_lines: 60
  key_links:
    - from: "src/astraea/execution/pattern_handlers.py"
      to: "PATTERN_HANDLERS dict"
      via: "handle_split registered for MappingPattern.SPLIT"
      pattern: "MappingPattern\\.SPLIT.*handle_split"
---

<objective>
Implement the three execution pipeline gaps: SPLIT pattern handler, key-based horizontal merge for multi-source domains, and Findings domain metadata variables (specimen, method, fasting).

Purpose: These are MED-11, MED-12, MED-13 from the FDA Compliance Audit. The SPLIT stub currently returns None for all inputs. Multi-source merge only supports vertical concat. Findings domains lack Expected variables SPEC, METHOD, FAST.

Output: Functional SPLIT handler, merge_mode parameter on merge_findings_sources, specimen/method/fasting pass-through in findings executor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-submission-readiness/15-RESEARCH.md
@src/astraea/execution/pattern_handlers.py
@src/astraea/execution/findings.py
@src/astraea/models/mapping.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SPLIT pattern handler</name>
  <files>src/astraea/execution/pattern_handlers.py, tests/unit/execution/test_split_pattern.py</files>
  <action>
Replace the `handle_split` stub (line 709) with a functional implementation that supports three derivation rule keywords:

1. **SUBSTRING(column, start, end)** -- Extract substring from source column. `df[col].astype(str).str[start:end]`.
2. **DELIMITER_PART(column, delimiter, index)** -- Split by delimiter and take the Nth part. `df[col].str.split(delimiter).str[index]`.
3. **REGEX_GROUP(column, pattern, group_index)** -- Extract regex group. `df[col].str.extract(pattern)[group_index]`.

Use the existing `parse_derivation_rule` function to parse the keyword and args from `mapping.derivation_rule`. Use `_resolve_column` for column name resolution (same pattern as handle_derivation).

Fallback behavior: if no derivation_rule is set but source_variable exists, return `df[source_col].copy()`. If derivation_rule is unrecognized, log warning and return source column unchanged (NOT None -- returning None causes downstream issues). Only return None series if there is truly no source data.

Add SPLIT to the `_DERIVATION_DISPATCH` dict if needed, or keep the existing PATTERN_HANDLERS routing.

Create `tests/unit/execution/test_split_pattern.py` with tests for:
- SUBSTRING extraction (basic, edge cases with out-of-range indices)
- DELIMITER_PART (comma-separated, dash-separated, index 0 and 1)
- REGEX_GROUP (simple group, named group)
- Fallback to source column when no derivation_rule
- Fallback to source column when derivation_rule is unrecognized
- None series when no source variable exists
  </action>
  <verify>pytest tests/unit/execution/test_split_pattern.py -v passes all tests</verify>
  <done>SPLIT pattern produces correct values for SUBSTRING, DELIMITER_PART, REGEX_GROUP; falls back to source column (not None) on unrecognized rules</done>
</task>

<task type="auto">
  <name>Task 2: Key-based horizontal merge + specimen/method/fasting pass-through</name>
  <files>src/astraea/execution/findings.py, tests/unit/execution/test_merge_horizontal.py, tests/unit/execution/test_findings_metadata.py</files>
  <action>
**Part A: Key-based horizontal merge (MED-12)**

Add a `merge_mode` parameter to `merge_findings_sources()` with values "concat" (default, existing behavior) and "join". When merge_mode="join":
- Identify common key columns across all DataFrames (STUDYID, USUBJID, VISITNUM, plus domain-specific keys like --TESTCD)
- Use `pd.merge()` with how="outer" on the key columns to horizontally join the DataFrames
- Suffix overlapping non-key columns with the source name to avoid collisions
- Log which key columns were used for the join

Keep the default as "concat" so existing behavior is unchanged. The executor should be updated to pass merge_mode="join" when the DomainMappingSpec or DomainPlan indicates a horizontal merge is needed (add detection: if source datasets have different columns that need combining horizontally, use "join").

**Part B: Specimen/method/fasting handling (MED-13)**

In the `FindingsExecutor` class (or the normalize function in findings.py), add pass-through logic for three Expected Findings variables:
- `{domain}SPEC` -- specimen type (e.g., LBSPEC): copy from source column if a column matching SPEC/SPECIMEN/SAMPLE exists
- `{domain}METHOD` -- method (e.g., LBMETHOD): copy from source column if METHOD/TESTMETHOD exists
- `{domain}FAST` -- fasting status (e.g., LBFAST): copy from source column if FAST/FASTING exists

These are "copy if present" variables -- no derivation needed. Use case-insensitive column matching. If not found in source, do NOT create the column (it is Expected, not Required).

Create tests:
- `test_merge_horizontal.py`: test join mode merges on USUBJID+VISITNUM, test concat mode unchanged, test mixed-column join with suffix handling
- `test_findings_metadata.py`: test SPEC/METHOD/FAST pass-through when present in source, test no column created when absent
  </action>
  <verify>pytest tests/unit/execution/test_merge_horizontal.py tests/unit/execution/test_findings_metadata.py -v passes</verify>
  <done>merge_findings_sources supports merge_mode="join" for horizontal key-based merges; FindingsExecutor populates SPEC/METHOD/FAST when source data contains them</done>
</task>

</tasks>

<verification>
```bash
pytest tests/unit/execution/test_split_pattern.py tests/unit/execution/test_merge_horizontal.py tests/unit/execution/test_findings_metadata.py -v
pytest tests/ -x -q  # Full suite regression
ruff check src/astraea/execution/pattern_handlers.py src/astraea/execution/findings.py
```
</verification>

<success_criteria>
- SPLIT pattern handler returns correct values for all three rule types
- Multi-source merge supports both concat and key-based join modes
- Findings domains populate SPEC/METHOD/FAST from source data when present
- All 1982+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-submission-readiness/15-01-SUMMARY.md`
</output>
