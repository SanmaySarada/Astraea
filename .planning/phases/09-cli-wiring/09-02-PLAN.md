---
phase: 09-cli-wiring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/cli/app.py
  - tests/unit/cli/test_map_domain_learning.py
autonomous: true

must_haves:
  truths:
    - "When a learning DB directory exists, map-domain automatically loads LearningRetriever and passes it to MappingEngine"
    - "When no learning DB exists, map-domain works identically to before (no error, no retriever)"
    - "Past corrections and approved mappings are injected as few-shot examples into mapping prompts"
  artifacts:
    - path: "src/astraea/cli/app.py"
      provides: "LearningRetriever wiring in map-domain command"
      contains: "learning_retriever"
    - path: "tests/unit/cli/test_map_domain_learning.py"
      provides: "Tests for learning retriever wiring in map-domain"
      min_lines: 40
  key_links:
    - from: "src/astraea/cli/app.py"
      to: "src/astraea/learning/retriever.py"
      via: "lazy import + LearningRetriever instantiation"
      pattern: "LearningRetriever"
    - from: "src/astraea/cli/app.py"
      to: "src/astraea/learning/vector_store.py"
      via: "lazy import + LearningVectorStore instantiation"
      pattern: "LearningVectorStore"
    - from: "src/astraea/cli/app.py"
      to: "src/astraea/mapping/engine.py"
      via: "MappingEngine constructor with learning_retriever kwarg"
      pattern: "MappingEngine.*learning_retriever"
---

<objective>
Wire LearningRetriever into the `map-domain` CLI command so that when a learning database exists, past corrections and approved mappings are automatically injected as few-shot examples into mapping prompts. Closes GAP-2 from the v1 milestone audit.

Purpose: The learning system (Phase 8) built all components -- example store, vector store, retriever, MappingEngine integration -- but the CLI never passes the retriever to MappingEngine. Users can ingest corrections and optimize prompts, but the knowledge never flows back into actual mapping. This closes the feedback loop.

Output: Modified `map-domain` command that auto-detects and loads learning DB, plus unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/astraea/cli/app.py
@src/astraea/mapping/engine.py
@src/astraea/learning/retriever.py
@src/astraea/learning/vector_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire LearningRetriever into map-domain CLI command</name>
  <files>src/astraea/cli/app.py</files>
  <action>
Modify the `map_domain` command function in app.py to:

1. Add a new optional CLI parameter:
```python
learning_db: Annotated[
    Path | None,
    typer.Option("--learning-db", help="Path to learning database directory (ChromaDB). Auto-detected from .astraea/learning/ if not specified."),
] = None,
```

2. Between step 3 (eCRF parsing) and step 4 (mapping engine), add learning retriever detection. Insert this logic:

```python
# Auto-detect or use provided learning DB
learning_retriever = None
if learning_db is not None:
    _learning_db_path = learning_db
elif Path(".astraea/learning").is_dir():
    _learning_db_path = Path(".astraea/learning")
else:
    _learning_db_path = None

if _learning_db_path is not None and _learning_db_path.is_dir():
    try:
        from astraea.learning.vector_store import LearningVectorStore
        from astraea.learning.retriever import LearningRetriever

        vector_store = LearningVectorStore(_learning_db_path)
        learning_retriever = LearningRetriever(vector_store)
        console.print(f"  [green]Learning DB loaded from {_learning_db_path}[/green]")
    except Exception as e:
        console.print(f"  [yellow]Warning: Could not load learning DB: {e}[/yellow]")
```

3. Modify the MappingEngine instantiation (currently line ~397) to pass the retriever:
```python
# Before:
engine = MappingEngine(llm_client, sdtm_ref, ct_ref)

# After:
engine = MappingEngine(llm_client, sdtm_ref, ct_ref, learning_retriever=learning_retriever)
```

All learning imports MUST be lazy (inside the if block), consistent with the TYPE_CHECKING guard already used in engine.py. If chromadb is not installed, the try/except catches the ImportError and continues without learning.
  </action>
  <verify>
Run `ruff check src/astraea/cli/app.py` -- zero errors.
Run `python -c "from astraea.cli.app import app; print('OK')"` -- no import errors.
  </verify>
  <done>
`map-domain` command auto-detects learning DB from `.astraea/learning/` or `--learning-db` option, instantiates LearningRetriever, and passes it to MappingEngine. Falls back gracefully when no DB exists or chromadb is unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for learning retriever wiring</name>
  <files>tests/unit/cli/test_map_domain_learning.py</files>
  <action>
Create test file verifying the learning retriever wiring logic. These tests should NOT require an API key or actual LLM calls -- mock the MappingEngine and LLM client.

Tests to write:

1. `test_map_domain_no_learning_db` -- Invoke map-domain without --learning-db and with no .astraea/learning/ directory. Mock MappingEngine to capture its constructor args. Verify `learning_retriever` kwarg is None.

2. `test_map_domain_with_learning_db_option` -- Create a tmp_path directory, invoke map-domain with `--learning-db <tmp_path>`. Mock LearningVectorStore and LearningRetriever. Verify MappingEngine receives a non-None learning_retriever.

3. `test_map_domain_auto_detect_learning_db` -- Create `.astraea/learning/` directory in the test's working directory (use monkeypatch to set cwd). Verify auto-detection works.

4. `test_map_domain_learning_db_import_error` -- Mock `importlib` or patch the import to raise ImportError (simulating chromadb not installed). Verify command continues without error and MappingEngine gets learning_retriever=None.

Use `unittest.mock.patch` to mock:
- `astraea.cli.app.MappingEngine` (or patch at the import site inside the function)
- `astraea.learning.vector_store.LearningVectorStore`
- `astraea.learning.retriever.LearningRetriever`
- The LLM client and profiling steps (to avoid needing real data/API key)

Since map-domain has complex setup (needs data_dir, ecrf_pdf, etc.), the simplest approach is to mock at a higher level: patch the entire mapping step or extract the learning detection into a testable helper function. If extracting a helper is cleaner, add:

```python
def _try_load_learning_retriever(
    learning_db: Path | None,
    console: Console,
) -> LearningRetriever | None:
```

as a module-level function in app.py, then test that function directly. This avoids needing to mock the entire map-domain pipeline.
  </action>
  <verify>
Run `pytest tests/unit/cli/test_map_domain_learning.py -x -q` -- all tests pass.
Run `ruff check tests/unit/cli/test_map_domain_learning.py` -- zero errors.
  </verify>
  <done>
4 tests verify learning retriever wiring: no DB (None), explicit --learning-db option, auto-detection from .astraea/learning/, and graceful fallback on import error.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/unit/cli/test_map_domain_learning.py -x -q` -- all 4 tests pass
2. `ruff check src/astraea/cli/app.py tests/unit/cli/test_map_domain_learning.py` -- zero violations
3. `pytest tests/ -x -q --timeout=120` -- all existing tests still pass
</verification>

<success_criteria>
- `map-domain` auto-detects `.astraea/learning/` directory and loads LearningRetriever
- `map-domain --learning-db <path>` explicitly loads from specified path
- When no learning DB exists, behavior is identical to pre-change (no error)
- When chromadb is not installed, graceful fallback with warning message
- MappingEngine receives learning_retriever parameter
- GAP-2 from v1-MILESTONE-AUDIT.md is closed
</success_criteria>

<output>
After completion, create `.planning/phases/09-cli-wiring/09-02-SUMMARY.md`
</output>
