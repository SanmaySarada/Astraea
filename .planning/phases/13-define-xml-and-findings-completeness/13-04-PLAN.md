---
phase: 13-define-xml-and-findings-completeness
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/execution/executor.py
  - tests/unit/execution/test_dtf_generation.py
autonomous: true

must_haves:
  truths:
    - "--DTF column is populated when date imputation occurs on --DTC variables"
    - "--TMF column is populated when time imputation occurs on --DTC variables"
    - "DTF/TMF are empty/null for non-imputed (full or truncated) dates"
    - "Infrastructure for DTF/TMF generation exists even if current pipeline rarely triggers it"
  artifacts:
    - path: "src/astraea/execution/executor.py"
      provides: "DTF/TMF generation logic wired into execute()"
      contains: "_generate_dtf_tmf_flags"
    - path: "tests/unit/execution/test_dtf_generation.py"
      provides: "Tests for DTF and TMF flag generation"
      min_lines: 60
  key_links:
    - from: "src/astraea/execution/executor.py"
      to: "result DataFrame"
      via: "stub empty-string columns for DTF/TMF vars in spec"
      pattern: "endswith.*DTF.*TMF"
---

<objective>
Wire date and time imputation flag (--DTF/--TMF) generation into the execution pipeline.

Purpose: SDTM-IG v3.4 requires --DTF when dates are imputed and --TMF when times are imputed. The imputation utility already exists in transforms/imputation.py but is not wired into the executor. For v1, the pipeline truncates partial dates (correct SDTM behavior) rather than imputing, so DTF/TMF flags will rarely fire -- but the infrastructure must exist for completeness and for future imputation support.
Output: DTF/TMF generation infrastructure wired into DatasetExecutor with tests confirming correct behavior for both truncated and imputed dates/times.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-define-xml-and-findings-completeness/13-RESEARCH.md

@src/astraea/execution/executor.py
@src/astraea/transforms/imputation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DTF and TMF generation into DatasetExecutor</name>
  <files>
    src/astraea/execution/executor.py
    tests/unit/execution/test_dtf_generation.py
  </files>
  <action>
1. Read `src/astraea/transforms/imputation.py` to understand the `get_date_imputation_flag()` API. It takes original_date (partial) and imputed_date (full) and returns the imputation flag character (D, M, Y) or empty string.

2. In `src/astraea/execution/executor.py`, add a private method `_generate_dtf_tmf_flags(self, result_df: pd.DataFrame, spec: DomainMappingSpec) -> pd.DataFrame`:
   - Find all variables ending in "DTF" OR "TMF" in the spec's variable_mappings
   - For each --DTF or --TMF variable found in the spec, ensure the column exists in the result DataFrame
   - For v1 implementation: Set DTF/TMF = empty string for all rows. This is infrastructure -- the actual imputation flag logic will be populated when/if date/time imputation is added.
   - Do NOT import or call `get_date_imputation_flag` -- the stub approach is correct for v1 since the pipeline truncates rather than imputes. Add a TODO comment referencing `get_date_imputation_flag` for future use.

   ```python
   def _generate_dtf_tmf_flags(self, result_df: pd.DataFrame, spec: DomainMappingSpec) -> pd.DataFrame:
       """Generate --DTF and --TMF date/time imputation flag columns.

       For v1, creates empty DTF/TMF columns as infrastructure. Actual imputation
       flag generation requires date/time imputation logic (current pipeline truncates,
       not imputes, partial dates per SDTM-IG rules).

       TODO: When date imputation is added, use get_date_imputation_flag() from
       astraea.transforms.imputation to populate DTF values. Add analogous
       get_time_imputation_flag() for TMF values.
       """
       flag_vars = [
           vm for vm in spec.variable_mappings
           if vm.sdtm_variable.endswith("DTF") or vm.sdtm_variable.endswith("TMF")
       ]
       for vm in flag_vars:
           if vm.sdtm_variable not in result_df.columns:
               result_df[vm.sdtm_variable] = ""
               logger.debug("Created imputation flag column: {}", vm.sdtm_variable)
       return result_df
   ```

3. Call `_generate_dtf_tmf_flags` in the `execute()` method, AFTER the main execution loop but BEFORE `_enforce_column_order()`. This ensures DTF/TMF columns are present for column ordering.

4. Create test file `tests/unit/execution/test_dtf_generation.py`:
   - Test `test_dtf_column_created`: Spec includes AEDTF variable, result DataFrame gets AEDTF column with empty strings.
   - Test `test_tmf_column_created`: Spec includes AETMF variable, result DataFrame gets AETMF column with empty strings.
   - Test `test_dtf_tmf_not_created_when_not_in_spec`: Spec has no --DTF/--TMF variables, no flag columns added.
   - Test `test_dtf_preserves_existing`: If AEDTF column already exists in result (from prior processing), it is not overwritten.
   - Test `test_multiple_flag_columns`: Spec with AESTDTF, AEENDTF, and AESTTMF -- all three created.

   For these tests, you can test the `_generate_dtf_tmf_flags` method directly by creating a DatasetExecutor instance and calling the private method with a test DataFrame and mock spec.
  </action>
  <verify>`pytest tests/unit/execution/test_dtf_generation.py -x -v` passes</verify>
  <done>DTF and TMF column generation wired into executor; columns exist in output when spec includes --DTF or --TMF variables</done>
</task>

<task type="auto">
  <name>Task 2: Full regression verification</name>
  <files></files>
  <action>
1. Run the complete test suite to verify no regressions:
   ```bash
   pytest tests/ -x -q --tb=short
   ```

2. Run ruff on all modified files:
   ```bash
   ruff check src/astraea/submission/define_xml.py src/astraea/execution/findings.py src/astraea/execution/executor.py src/astraea/models/controlled_terms.py
   ```

3. If any test failures, fix them. Common expected issues:
   - Existing define.xml integration tests may need updates if they check VLD structure
   - Existing Findings execution tests may now have extra columns (STRESC, STRESN, etc.)

4. Report final test count.
  </action>
  <verify>`pytest tests/ -x -q` shows all tests passing; `ruff check src/ tests/` clean</verify>
  <done>All existing tests pass, no regressions, ruff clean</done>
</task>

</tasks>

<verification>
```bash
pytest tests/ -x -q --tb=short
ruff check src/ tests/
```
</verification>

<success_criteria>
- DTF columns created for any --DTF variable in the mapping spec
- TMF columns created for any --TMF variable in the mapping spec
- All 1685+ existing tests still pass
- No ruff violations in modified files
- New tests for DTF and TMF generation pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-define-xml-and-findings-completeness/13-04-SUMMARY.md`
</output>
