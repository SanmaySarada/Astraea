---
phase: 13-define-xml-and-findings-completeness
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/astraea/execution/findings.py
  - tests/unit/execution/test_findings_derivations.py
autonomous: true

must_haves:
  truths:
    - "Findings domains have --STRESC, --STRESN, --STRESU columns after execution"
    - "STRESN is NaN for non-numeric results (text lab values like 'YELLOW')"
    - "NRIND is LOW, HIGH, or NORMAL based on comparison to reference ranges"
    - "NRIND is null when no reference ranges or no numeric result"
  artifacts:
    - path: "src/astraea/execution/findings.py"
      provides: "derive_standardized_results and derive_nrind functions"
      contains: "derive_standardized_results"
    - path: "tests/unit/execution/test_findings_derivations.py"
      provides: "Tests for STRESC/STRESN/STRESU/NRIND derivation"
      min_lines: 80
  key_links:
    - from: "src/astraea/execution/findings.py"
      to: "pandas"
      via: "pd.to_numeric for STRESN, np.select for NRIND"
      pattern: "pd\\.to_numeric.*errors.*coerce"
---

<objective>
Add Findings domain derivations: standardized results (--STRESC/--STRESN/--STRESU) and normal range indicator (--NRIND).

Purpose: STRESC, STRESN, STRESU, and NRIND are Expected variables per SDTM-IG v3.4 for all Findings domains. Without them, generated datasets are incomplete and will trigger P21 warnings for missing expected variables.
Output: Two derivation functions in findings.py wired into FindingsExecutor, with comprehensive tests covering numeric, text, mixed, and missing-range edge cases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-define-xml-and-findings-completeness/13-RESEARCH.md

@src/astraea/execution/findings.py
@src/astraea/execution/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement derive_standardized_results and derive_nrind</name>
  <files>
    src/astraea/execution/findings.py
  </files>
  <action>
1. Add `import numpy as np` at top of findings.py.

2. Add function `derive_standardized_results(df: pd.DataFrame, domain_prefix: str) -> pd.DataFrame`:
   - Takes a DataFrame with --ORRES and optionally --ORRESU columns
   - Derives:
     - `{prefix}STRESC` = character copy of `{prefix}ORRES` (always)
     - `{prefix}STRESN` = `pd.to_numeric(df[orres], errors="coerce")` (NaN for non-numeric)
     - `{prefix}STRESU` = copy of `{prefix}ORRESU` if it exists, else leave absent
   - Returns the modified DataFrame (in-place modification is fine)
   - If ORRES column doesn't exist in df, return df unchanged
   - For v1, NO unit conversion -- copy ORRESU directly to STRESU. Document this in docstring.

3. Add function `derive_nrind(df: pd.DataFrame, domain_prefix: str) -> pd.DataFrame`:
   - Takes a DataFrame with --STRESN and optionally --STNRLO/--STNRHI columns
   - Derives `{prefix}NRIND`:
     - "LOW" when STRESN < STNRLO (and both are numeric/non-null)
     - "HIGH" when STRESN > STNRHI (and both are numeric/non-null)
     - "NORMAL" when STNRLO <= STRESN <= STNRHI (and all three are numeric/non-null)
     - null (pd.NA) when STRESN is NaN, or both STNRLO and STNRHI are missing
   - Use `np.select(conditions, choices, default=None)` for vectorized logic
   - Convert the result column to object dtype with None/pd.NA for missing values
   - If STRESN column doesn't exist, return df unchanged
   - Handle edge case: only one bound available (only STNRLO or only STNRHI) -- derive LOW/HIGH where applicable, leave null where the missing bound would be needed

4. Wire both functions into FindingsExecutor by adding a private method `_derive_findings_variables(self, df: pd.DataFrame, domain_prefix: str) -> pd.DataFrame` that calls `derive_standardized_results` then `derive_nrind` in sequence.

5. Call `_derive_findings_variables` at the END of `execute_lb`, `execute_eg`, and `execute_vs`, AFTER the DatasetExecutor.execute() call but BEFORE SUPPQUAL generation. Pass the domain prefix ("LB", "EG", "VS" respectively).

   Important: The derived columns (STRESC, STRESN, STRESU, NRIND) will NOT be in the original spec's variable_mappings if the LLM didn't propose them. This is fine -- the executor's `_enforce_column_order()` already ran. We're adding columns AFTER execution. The columns will appear at the end of the DataFrame. This is acceptable because XPT column order enforcement happens at write time, not during execution. If the spec DID include these variables, they'll already have placeholder values that get overwritten.

6. Export `derive_standardized_results` and `derive_nrind` from the module for direct testing and reuse.
  </action>
  <verify>`python -c "from astraea.execution.findings import derive_standardized_results, derive_nrind; print('OK')"` succeeds</verify>
  <done>Two derivation functions implemented and wired into all three FindingsExecutor methods</done>
</task>

<task type="auto">
  <name>Task 2: Tests for standardized results and NRIND derivation</name>
  <files>
    tests/unit/execution/test_findings_derivations.py
  </files>
  <action>
1. Create test file `tests/unit/execution/test_findings_derivations.py` (ensure `tests/unit/execution/__init__.py` exists).

2. Import `derive_standardized_results` and `derive_nrind` from `astraea.execution.findings`.

3. Test `test_stresc_copies_orres`: DataFrame with LBORRES=["5.2", "YELLOW", "3.1"] produces LBSTRESC=["5.2", "YELLOW", "3.1"].

4. Test `test_stresn_numeric_parse`: LBORRES=["5.2", "YELLOW", "3.1", None, ""] produces LBSTRESN=[5.2, NaN, 3.1, NaN, NaN].

5. Test `test_stresu_copies_orresu`: LBORRESU=["mg/dL", "mg/dL", None] produces LBSTRESU=["mg/dL", "mg/dL", None].

6. Test `test_stresu_absent_when_no_orresu`: DataFrame without LBORRESU column produces no LBSTRESU column.

7. Test `test_no_orres_returns_unchanged`: DataFrame without LBORRES returns unchanged (no error).

8. Test `test_nrind_normal`: LBSTRESN=5.0, LBSTNRLO=3.0, LBSTNRHI=7.0 -> LBNRIND="NORMAL".

9. Test `test_nrind_low`: LBSTRESN=1.0, LBSTNRLO=3.0, LBSTNRHI=7.0 -> LBNRIND="LOW".

10. Test `test_nrind_high`: LBSTRESN=10.0, LBSTNRLO=3.0, LBSTNRHI=7.0 -> LBNRIND="HIGH".

11. Test `test_nrind_null_when_no_ranges`: LBSTRESN=5.0, no LBSTNRLO/LBSTNRHI -> LBNRIND is null.

12. Test `test_nrind_null_for_non_numeric`: LBSTRESN=NaN -> LBNRIND is null regardless of ranges.

13. Test `test_nrind_partial_range_low_only`: Only LBSTNRLO=3.0 (no hi) -> LOW when result < 3, null otherwise (can't determine NORMAL without upper bound).

14. Test `test_nrind_partial_range_high_only`: Only LBSTNRHI=7.0 (no lo) -> HIGH when result > 7, null otherwise.

15. Test `test_mixed_results_vectorized`: DataFrame with 5 rows of mixed numeric/text results with varying ranges, verify correct NRIND per row.

16. Test `test_eg_prefix`: Use "EG" prefix to verify domain-agnostic behavior (EGORRES -> EGSTRESC, EGSTRESN, etc.).
  </action>
  <verify>`pytest tests/unit/execution/test_findings_derivations.py -x -v` passes all tests</verify>
  <done>All derivation edge cases tested: numeric, text, mixed, missing ranges, partial ranges, multiple prefixes</done>
</task>

</tasks>

<verification>
```bash
pytest tests/unit/execution/test_findings_derivations.py -x -v
pytest tests/unit/ -x -q  # no regressions
pytest tests/integration/execution/test_lb_execution.py tests/integration/execution/test_eg_execution.py tests/integration/execution/test_vs_execution.py -x -q  # integration still passes
ruff check src/astraea/execution/findings.py
```
</verification>

<success_criteria>
- derive_standardized_results correctly produces STRESC (always), STRESN (numeric only), STRESU (when ORRESU exists)
- derive_nrind correctly produces LOW/HIGH/NORMAL/null based on result vs reference ranges
- Non-numeric results produce NaN STRESN (never 0)
- Missing ranges produce null NRIND (never crash)
- All FindingsExecutor methods (execute_lb, execute_eg, execute_vs) call the derivation
- All existing integration tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-define-xml-and-findings-completeness/13-03-SUMMARY.md`
</output>
